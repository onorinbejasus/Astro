// Generated by CoffeeScript 1.3.1
var Projection,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Projection = (function() {

  Projection.name = 'Projection';

  function Projection(Math) {
    this.Math = Math;
    this.unproject = __bind(this.unproject, this);

    this.init = __bind(this.init, this);

    this.parameters = null;
  }

  Projection.prototype.init = function(image, fits, HTM, survey) {
    var FITS, size, xhr,
      _this = this;
    if (survey === "SDSS") {
      size = [1984, 1361];
    } else if (survey === "LSST") {
      size = [4072, 4000];
    }
    FITS = require('fits');
    this.parameters = new Object;
    /*
    		$.ajaxSetup({'async': false})
    		# grab the image headers
    		$.getJSON("../Astro/imageHeader.php?url=#{image}", (data) =>
    			$.each(data, (key, val) =>
    				if key == "CRVAL_1"
    					@parameters.crval1 = val
    				if key == "CRVAL_2"
    					@parameters.crval2 = val
    				if key == "CRPIX_1"
    					@parameters.crpix1 = val
    				if key == "CRPIX_2"
    					@parameters.crpix2 = val
    				if key == "CD1_1"
    					@parameters.cd11 = val
    				if key == "CD1_2"
    					@parameters.cd12 = val
    				if key == "CD2_1"
    					@parameters.cd21 = val
    				if key == "CD2_2"
    					@parameters.cd22 = val
    			)
    		)
    		$.ajaxSetup({'async': true})
    */

    xhr = new XMLHttpRequest();
    xhr.responseType = 'arraybuffer';
    xhr.open('GET', fits);
    xhr.onload = function(e) {
      var coords, hdu;
      fits = new FITS.File(xhr.response);
      hdu = fits.getHDU();
      _this.parameters.ctype1 = hdu.getCard("CTYPE1");
      _this.parameters.ctype1 = hdu.header["CTYPE1"];
      _this.parameters.ctype2 = hdu.getCard("CTYPE2");
      _this.parameters.ctype2 = hdu.header["CTYPE2"];
      _this.parameters.crpix1 = hdu.getCard("CRPIX1");
      _this.parameters.crpix1 = hdu.header["CRPIX1"];
      _this.parameters.crpix2 = hdu.getCard("CRPIX2");
      _this.parameters.crpix2 = hdu.header["CRPIX2"];
      _this.parameters.crval1 = hdu.getCard("CRVAL1");
      _this.parameters.crval1 = hdu.header["CRVAL1"];
      _this.parameters.crval2 = hdu.getCard("CRVAL2");
      _this.parameters.crval2 = hdu.header["CRVAL2"];
      _this.parameters.cd11 = hdu.getCard("CD1_1");
      _this.parameters.cd11 = hdu.header["CD1_1"];
      _this.parameters.cd12 = hdu.getCard("CD1_2");
      _this.parameters.cd12 = hdu.header["CD1_2"];
      _this.parameters.cd21 = hdu.getCard("CD2_1");
      _this.parameters.cd21 = hdu.header["CD2_1"];
      _this.parameters.cd22 = hdu.getCard("CD2_2");
      _this.parameters.cd22 = hdu.header["CD2_2"];
      coords = _this.unproject(size[0], size[1]);
      HTM.initTexture(image);
      HTM.createSphere(coords[0], coords[1]);
      return HTM.setFlag();
    };
    xhr.send();
  };

  Projection.prototype.unproject = function(xsize, ysize) {
    var crval, dec, decpole, dtor, i, index, indices, j, l, lat, latpole, long, lonpole, lp, m, mat, mp, n, np, phi, r, r11, r12, r13, r21, r22, r23, r31, r32, r33, ra, rapole, rtod, theta, tmp, x, xpix, y, ypix, _i, _j, _k, _results, _results1;
    console.log(this.parameters);
    rtod = 57.29577951308323;
    dtor = 0.0174532925;
    xpix = (function() {
      _results = [];
      for (var _i = 1; 1 <= xsize ? _i <= xsize : _i >= xsize; 1 <= xsize ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    ypix = (function() {
      _results1 = [];
      for (var _j = 1; 1 <= ysize ? _j <= ysize : _j >= ysize; 1 <= ysize ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this);
    ra = [0, 1, 2, 3];
    dec = [0, 1, 2, 3];
    indices = [[0, 0], [0, ysize - 1], [xsize - 1, ysize - 1], [xsize - 1, 0]];
    crval = [this.parameters.crval1, this.parameters.crval2];
    console.log("crval1,2: ", crval);
    console.log("cd11: ", this.parameters.cd11);
    console.log("cd12: ", this.parameters.cd12);
    console.log("cd21: ", this.parameters.cd21);
    console.log("cd22: ", this.parameters.cd22);
    for (index = _k = 0; _k <= 3; index = ++_k) {
      i = indices[index][0];
      j = indices[index][1];
      x = this.parameters.cd11 * (xpix[i] - this.parameters.crpix1) + this.parameters.cd12 * (ypix[j] - this.parameters.crpix2);
      y = this.parameters.cd21 * (xpix[i] - this.parameters.crpix1) + this.parameters.cd22 * (ypix[j] - this.parameters.crpix2);
      if (this.parameters.ctype1 === "DEC--TAN") {
        tmp = x;
        x = y;
        y = tmp;
        if (index === 0) {
          crval = this.Math.rotate(crval);
        }
      }
      console.log("new crval: ", crval);
      console.log("x,y: ", x, y);
      long = this.Math.arg(-y, x);
      lat = (Math.PI / 2.0) * dtor;
      r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
      if (r > 0.0) {
        lat = Math.atan((180.0 / Math.PI) / r);
      }
      lat = Math.atan(rtod / r);
      l = Math.cos(lat) * Math.cos(long);
      m = Math.cos(lat) * Math.sin(long);
      n = Math.sin(lat);
      phi = 0.0;
      theta = 90.0 * dtor;
      lonpole = crval[1] > theta * rtod ? 0.0 : 180.0 * dtor;
      latpole = 90.0 * dtor;
      rapole = crval[0] * dtor;
      decpole = crval[1] * dtor;
      r11 = -1.0 * Math.sin(rapole) * Math.sin(lonpole) - Math.cos(rapole) * Math.cos(lonpole) * Math.sin(decpole);
      r12 = Math.cos(rapole) * Math.sin(lonpole) - Math.sin(rapole) * Math.cos(lonpole) * Math.sin(decpole);
      r13 = Math.cos(lonpole) * Math.cos(decpole);
      r21 = Math.sin(rapole) * Math.cos(lonpole) - Math.cos(rapole) * Math.sin(lonpole) * Math.sin(decpole);
      r22 = -1.0 * Math.cos(rapole) * Math.cos(lonpole) - Math.sin(rapole) * Math.sin(lonpole) * Math.sin(decpole);
      r23 = Math.sin(lonpole) * Math.cos(decpole);
      r31 = Math.cos(rapole) * Math.cos(decpole);
      r32 = Math.sin(rapole) * Math.cos(decpole);
      r33 = Math.sin(decpole);
      mat = [[r11, r21, r31], [r12, r22, r32], [r13, r23, r33]];
      lp = mat[0][0] * l + mat[0][1] * m + mat[0][2] * n;
      mp = mat[1][0] * l + mat[1][1] * m + mat[1][2] * n;
      np = mat[2][0] * l + mat[2][1] * m + mat[2][2] * n;
      dec[index] = Math.asin(np) * rtod;
      ra[index] = Math.atan2(mp, lp) * rtod;
      if (ra[index] < 0.0) {
        ra[index] += 360.0;
      } else if (ra[index] > 360.0) {
        ra[index] -= 360;
      }
    }
    console.log("ra,dec: ", ra, dec);
    return [ra, dec];
  };

  return Projection;

})();
