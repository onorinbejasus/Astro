// Generated by CoffeeScript 1.3.2
var HTM,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

HTM = (function() {

  HTM.verts = null;

  HTM.tri = null;

  HTM.names = null;

  HTM.VertexPositionBuffer = null;

  HTM.VertexColorBuffer = null;

  HTM.VertexIndexBuffer = null;

  HTM.VertexTextureCoordBuffer = null;

  HTM.VertexNormalBuffer = null;

  HTM.Texture = null;

  HTM.initTriangles = null;

  function HTM(levels, gl, Math, type) {
    var coords;
    this.levels = levels;
    this.gl = gl;
    this.Math = Math;
    this.renderSphere = __bind(this.renderSphere, this);

    this.renderHTM = __bind(this.renderHTM, this);

    this.bindSphere = __bind(this.bindSphere, this);

    this.bindHTM = __bind(this.bindHTM, this);

    this.createSphere = __bind(this.createSphere, this);

    this.subdivide = __bind(this.subdivide, this);

    this.createHTM = __bind(this.createHTM, this);

    this.debugColor = __bind(this.debugColor, this);

    this.initTexture = __bind(this.initTexture, this);

    this.handleLoadedTexture = __bind(this.handleLoadedTexture, this);

    this.getColors = __bind(this.getColors, this);

    this.getNames = __bind(this.getNames, this);

    this.getTriangles = __bind(this.getTriangles, this);

    this.getInitTriangles = __bind(this.getInitTriangles, this);

    this.mutableTri = [[[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]], [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]], [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]], [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]], [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]], [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]], [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]], [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]];
    this.initTriangles = [[[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]], [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]], [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]], [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]], [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]], [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]], [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]], [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]];
    if (type === "sky") {
      this.proj = new Projection(this.Math);
      this.proj.getHeader("./images/testframe.jpeg");
      coords = this.proj.unproject(1984, 1361);
      this.initTexture("./images/testframe.jpeg");
      this.createSphere(coords[0], coords[1]);
    } else if (type === "sphere") {
      this.createSphere();
      this.initTexture("./images/toast.png");
    }
    return;
  }

  HTM.prototype.getInitTriangles = function() {
    return this.initTriangles;
  };

  HTM.prototype.getTriangles = function() {
    return this.tri;
  };

  HTM.prototype.getNames = function() {
    return this.names;
  };

  HTM.prototype.getColors = function() {
    return this.colors;
  };

  HTM.prototype.handleLoadedTexture = function(texture) {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, texture.image);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    return this.gl.bindTexture(this.gl.TEXTURE_2D, null);
  };

  HTM.prototype.initTexture = function(image) {
    var _this = this;
    this.Texture = this.gl.createTexture();
    this.Texture.image = new Image();
    this.Texture.image.onload = function() {
      return _this.handleLoadedTexture(_this.Texture);
    };
    return this.Texture.image.src = image;
  };

  HTM.prototype.debugColor = function() {
    var color, depth, j, k, l, num, _i, _j, _k, _l, _len, _len1, _len2, _ref;
    color = [];
    this.colors = [[[0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 1.0]]];
    depth = Math.pow(4, this.levels) * 16;
    for (num = _i = depth; depth <= 0 ? _i <= 0 : _i >= 0; num = depth <= 0 ? ++_i : --_i) {
      _ref = this.colors;
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        j = _ref[_j];
        for (_k = 0, _len1 = j.length; _k < _len1; _k++) {
          k = j[_k];
          for (_l = 0, _len2 = k.length; _l < _len2; _l++) {
            l = k[_l];
            color.push(l);
          }
        }
      }
    }
    this.VertexColorBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexColorBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(color), this.gl.STATIC_DRAW);
    this.VertexColorBuffer.itemSize = 4;
    this.VertexColorBuffer.numItems = 8 * Math.pow(4, this.levels) * 6;
  };

  HTM.prototype.createHTM = function() {
    var component, initNames, it, triangles, vert, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
    this.verts = [];
    this.names = [];
    this.tri = [];
    it = 0;
    initNames = ["S0", "S1", "S2", "S3", "N0", "N1", "N2", "N3"];
    /*
    		@initTriangles = [
    			# N3
    			[[0.0, 0.0, -1.0],
    			[0.0, 1.0, 0.0],
    			[1.0, 0.0, 0.0 ]]
    		]
    */

    this.names = initNames;
    this.tri = this.initTriangles;
    if (this.levels === 0) {
      _ref = this.mutableTri;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        triangles = _ref[_i];
        triangles.splice(2, 0, triangles[1]);
        triangles.push(triangles[3]);
        triangles.push(triangles[0]);
        for (_j = 0, _len1 = triangles.length; _j < _len1; _j++) {
          vert = triangles[_j];
          for (_k = 0, _len2 = vert.length; _k < _len2; _k++) {
            component = vert[_k];
            this.verts.push(component);
          }
        }
      }
    } else {
      this.tri = [];
      this.names = [];
      _ref1 = this.initTriangles;
      for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
        triangles = _ref1[_l];
        this.subdivide(triangles, this.levels - 1, initNames[it++]);
      }
    }
    this.VertexPositionBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.verts), this.gl.STATIC_DRAW);
    this.VertexPositionBuffer.itemSize = 3;
    this.VertexPositionBuffer.numItems = 8 * Math.pow(4, this.levels) * 6;
    this.debugColor();
  };

  HTM.prototype.subdivide = function(v, l, name) {
    var component, it, mag, mutTriangles, names, newTriangles, triangle, vert, w0, w1, w2, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m;
    names = ["" + name + "0", "" + name + "1", "" + name + "2", "" + name + "3"];
    it = 0;
    mag = this.Math.magnitude(v[1], v[2]);
    w0 = [];
    w0.push((v[1][0] + v[2][0]) / mag);
    if (!(w0[0] != null)) {
      w0[0] = 0;
    }
    w0.push((v[1][1] + v[2][1]) / mag);
    if (!(w0[1] != null)) {
      w0[1] = 0;
    }
    w0.push((v[1][2] + v[2][2]) / mag);
    if (!(w0[2] != null)) {
      w0[2] = 0;
    }
    mag = this.Math.magnitude(v[0], v[2]);
    w1 = [];
    w1.push((v[0][0] + v[2][0]) / mag);
    if (!(w1[0] != null)) {
      w1[0] = 0;
    }
    w1.push((v[0][1] + v[2][1]) / mag);
    if (!(w1[1] != null)) {
      w1[1] = 0;
    }
    w1.push((v[0][2] + v[2][2]) / mag);
    if (!(w1[2] != null)) {
      w1[2] = 0;
    }
    mag = this.Math.magnitude(v[0], v[1]);
    w2 = [];
    w2.push((v[0][0] + v[1][0]) / mag);
    if (!(w2[0] != null)) {
      w2[0] = 0;
    }
    w2.push((v[0][1] + v[1][1]) / mag);
    if (!(w2[1] != null)) {
      w2[1] = 0;
    }
    w2.push((v[0][2] + v[1][2]) / mag);
    if (!(w2[2] != null)) {
      w2[2] = 0;
    }
    newTriangles = [[v[0], w2, w1], [v[1], w0, w2], [v[2], w1, w0], [w0, w1, w2]];
    mutTriangles = [[v[0], w2, w1], [v[1], w0, w2], [v[2], w1, w0], [w0, w1, w2]];
    it = 0;
    if (l === 0) {
      for (_i = 0, _len = mutTriangles.length; _i < _len; _i++) {
        triangle = mutTriangles[_i];
        this.tri.push(newTriangles[it++]);
        triangle.splice(2, 0, triangle[1]);
        triangle.push(triangle[3]);
        triangle.push(triangle[0]);
        for (_j = 0, _len1 = triangle.length; _j < _len1; _j++) {
          vert = triangle[_j];
          for (_k = 0, _len2 = vert.length; _k < _len2; _k++) {
            component = vert[_k];
            this.verts.push(component);
          }
        }
      }
      for (_l = 0, _len3 = names.length; _l < _len3; _l++) {
        name = names[_l];
        this.names.push(name);
      }
    } else {
      for (_m = 0, _len4 = newTriangles.length; _m < _len4; _m++) {
        triangle = newTriangles[_m];
        this.subdivide(triangle, l - 1, names[it++]);
      }
    }
  };

  HTM.prototype.createSphere = function(ra, dec) {
    var cosPhi, cosTheta, decLen, first, i, indexData, j, latNumber, latitudeBands, longNumber, longitudeBands, maxX, maxY, maxZ, minX, minY, minZ, normalData, phi, raLen, radius, second, sinPhi, sinTheta, textureCoordData, theta, u, v, vertexPositionData, x, y, z, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1;
    latitudeBands = 180;
    longitudeBands = 360;
    radius = 4;
    vertexPositionData = [];
    normalData = [];
    textureCoordData = [];
    /* if ra and dec are specified for the sphere, 
    			use them
    */

    if ((ra != null) && (dec != null)) {
      minX = 100;
      maxX = -100;
      minY = 100;
      maxY = -100;
      minZ = 100;
      maxZ = -100;
      raLen = parseInt(1984 / 30) - 1;
      decLen = parseInt(1361 / 30) - 1;
      for (i = _i = 0; _i <= 1984; i = _i += 30) {
        for (j = _j = 0; _j <= 1361; j = _j += 30) {
          phi = ra[i][j] * Math.PI / 180.0;
          theta = dec[i][j] * Math.PI / 180.0;
          sinTheta = Math.sin(theta);
          cosTheta = Math.cos(theta);
          sinPhi = Math.sin(phi);
          cosPhi = Math.cos(phi);
          x = sinPhi * sinTheta;
          y = cosTheta;
          z = cosPhi * sinTheta;
          if (x > maxX) {
            maxX = x;
          }
          if (y > maxY) {
            maxY = y;
          }
          if (z > maxZ) {
            maxZ = z;
          }
          if (x < minX) {
            minX = x;
          }
          if (y < minY) {
            minY = y;
          }
          if (z < minZ) {
            minZ = z;
          }
          u = 1 - (i / 1984);
          v = 1 - (j / 1361);
          normalData.push(x);
          normalData.push(y);
          normalData.push(z);
          textureCoordData.push(u);
          textureCoordData.push(v);
          vertexPositionData.push(radius * x);
          vertexPositionData.push(radius * y);
          vertexPositionData.push(radius * z);
        }
      }
      console.log("min", minX, minY, minZ);
      console.log("max", maxX, maxY, maxZ);
      indexData = [];
      for (latNumber = _k = 0; 0 <= raLen ? _k <= raLen : _k >= raLen; latNumber = 0 <= raLen ? ++_k : --_k) {
        for (longNumber = _l = 0; 0 <= decLen ? _l <= decLen : _l >= decLen; longNumber = 0 <= decLen ? ++_l : --_l) {
          first = (latNumber * (decLen + 1)) + longNumber;
          second = first + decLen + 1;
          indexData.push(first);
          indexData.push(second);
          indexData.push(first + 1);
          indexData.push(second);
          indexData.push(second + 1);
          indexData.push(first + 1);
        }
      }
    } else {
      for (latNumber = _m = 0; 0 <= latitudeBands ? _m <= latitudeBands : _m >= latitudeBands; latNumber = 0 <= latitudeBands ? ++_m : --_m) {
        theta = latNumber * Math.PI / latitudeBands;
        sinTheta = Math.sin(theta);
        cosTheta = Math.cos(theta);
        for (longNumber = _n = 0; 0 <= longitudeBands ? _n <= longitudeBands : _n >= longitudeBands; longNumber = 0 <= longitudeBands ? ++_n : --_n) {
          phi = longNumber * 2 * Math.PI / longitudeBands;
          sinPhi = Math.sin(phi);
          cosPhi = Math.cos(phi);
          x = cosPhi * sinTheta;
          y = cosTheta;
          z = sinPhi * sinTheta;
          u = 1 - (longNumber / longitudeBands);
          v = 1 - (latNumber / latitudeBands);
          normalData.push(x);
          normalData.push(y);
          normalData.push(z);
          textureCoordData.push(u);
          textureCoordData.push(v);
          vertexPositionData.push(radius * x);
          vertexPositionData.push(radius * y);
          vertexPositionData.push(radius * z);
        }
      }
      indexData = [];
      for (latNumber = _o = 0, _ref = latitudeBands - 1; 0 <= _ref ? _o <= _ref : _o >= _ref; latNumber = 0 <= _ref ? ++_o : --_o) {
        for (longNumber = _p = 0, _ref1 = longitudeBands - 1; 0 <= _ref1 ? _p <= _ref1 : _p >= _ref1; longNumber = 0 <= _ref1 ? ++_p : --_p) {
          first = (latNumber * (longitudeBands + 1)) + longNumber;
          second = first + longitudeBands + 1;
          indexData.push(first);
          indexData.push(second);
          indexData.push(first + 1);
          indexData.push(second);
          indexData.push(second + 1);
          indexData.push(first + 1);
        }
      }
    }
    this.VertexNormalBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexNormalBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normalData), this.gl.STATIC_DRAW);
    this.VertexNormalBuffer.itemSize = 3;
    this.VertexNormalBuffer.numItems = normalData.length / 3;
    this.VertexPositionBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), this.gl.STATIC_DRAW);
    this.VertexPositionBuffer.itemSize = 3;
    this.VertexPositionBuffer.numItems = vertexPositionData.length / 3;
    this.VertexIndexBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.VertexIndexBuffer);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), this.gl.STATIC_DRAW);
    this.VertexIndexBuffer.itemSize = 1;
    this.VertexIndexBuffer.numItems = indexData.length;
    this.VertexTextureCoordBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(textureCoordData), this.gl.STATIC_DRAW);
    this.VertexTextureCoordBuffer.itemSize = 2;
    this.VertexTextureCoordBuffer.numItems = textureCoordData.length / 2;
  };

  HTM.prototype.bindHTM = function(shaderProgram) {
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    this.gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, this.VertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexColorBuffer);
    this.gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, this.VertexColorBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
  };

  HTM.prototype.bindSphere = function(shaderProgram) {
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.Texture);
    this.gl.uniform1i(shaderProgram.samplerUniform, 0);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    this.gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, this.VertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
    this.gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, this.VertexTextureCoordBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexNormalBuffer);
    this.gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, this.VertexNormalBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.VertexIndexBuffer);
  };

  HTM.prototype.renderHTM = function(renderMode) {
    this.gl.drawArrays(renderMode, 0, this.VertexPositionBuffer.numItems);
  };

  HTM.prototype.renderSphere = function(renderMode) {
    return this.gl.drawElements(renderMode, this.VertexIndexBuffer.numItems, this.gl.UNSIGNED_SHORT, 0);
  };

  return HTM;

})();
