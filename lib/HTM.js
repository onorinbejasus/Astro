// Generated by CoffeeScript 1.3.2
var HTM,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

HTM = (function() {

  HTM.verts = [];

  HTM.VertexPositionBuffer = 0;

  HTM.VertexColorBuffer = 0;

  function HTM(levels) {
    this.levels = levels;
    this.render = __bind(this.render, this);

    this.bind = __bind(this.bind, this);

    this.subdivide = __bind(this.subdivide, this);

    this.createHTM = __bind(this.createHTM, this);

    createHTM();
  }

  HTM.prototype.createHTM = function() {
    var components, initTriangles, triangles, verts, _i, _j, _len, _len1, _results, _results1;
    initTriangles = [[[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]], [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]], [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]], [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]], [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]], [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]], [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]], [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]];
    if (this.levels === 0) {
      _results = [];
      for (_i = 0, _len = initTriangles.length; _i < _len; _i++) {
        triangles = initTriangles[_i];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = triangles.length; _j < _len1; _j++) {
            verts = triangles[_j];
            _results1.push((function() {
              var _k, _len2, _results2;
              _results2 = [];
              for (_k = 0, _len2 = verts.length; _k < _len2; _k++) {
                components = verts[_k];
                _results2.push(this.verts.push(components));
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    } else {
      _results1 = [];
      for (_j = 0, _len1 = initTriangles.length; _j < _len1; _j++) {
        triangles = initTriangles[_j];
        _results1.push(subdivide(triangles, this.levels - 1));
      }
      return _results1;
    }
  };

  HTM.prototype.subdivide = function(v) {
    var components, newTriangles, triangles, verts, w0, w1, w2, _i, _j, _len, _len1, _results, _results1;
    w0 = [];
    w0.push(v[1][0] + v[2][0]) / Math.abs(v[1][0] + v[2][0]);
    if (!(w0[0] != null)) {
      w0[0] = 0;
    }
    w0.push(v[1][1] + v[2][1]) / Math.abs(v[1][1] + v[2][1]);
    if (!(w0[1] != null)) {
      w0[1] = 0;
    }
    w0.push(v[1][2] + v[2][2]) / Math.abs(v[1][2] + v[2][2]);
    if (!(w0[2] != null)) {
      w0[2] = 0;
    }
    w1 = [];
    w1.push(v[0][0] + v[2][0]) / Math.abs(v[0][0] + v[2][0]);
    if (!(w1[0] != null)) {
      w1[0] = 0;
    }
    w1.push(v[0][1] + v[2][1]) / Math.abs(v[0][1] + v[2][1]);
    if (!(w1[1] != null)) {
      w1[1] = 0;
    }
    w1.push(v[0][2] + v[2][2]) / Math.abs(v[0][2] + v[2][2]);
    if (!(w1[2] != null)) {
      w1[2] = 0;
    }
    w2 = [];
    w2.push(v[0][0] + v[1][0]) / Math.abs(v[0][0] + v[1][0]);
    if (!(w2[0] != null)) {
      w2[0] = 0;
    }
    w2.push(v[0][1] + v[1][1]) / Math.abs(v[0][1] + v[1][1]);
    if (!(w2[1] != null)) {
      w2[1] = 0;
    }
    w2.push(v[0][2] + v[1][2]) / Math.abs(v[0][2] + v[1][2]);
    if (!(w2[2] != null)) {
      w2[2] = 0;
    }
    newTriangles = [[v[0], w2, w1], [v[1], w0, w2], [v[2], w1, w0], [w0, w1, w2]];
    if (this.levels === 0) {
      _results = [];
      for (_i = 0, _len = newTriangles.length; _i < _len; _i++) {
        triangles = newTriangles[_i];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = triangles.length; _j < _len1; _j++) {
            verts = triangles[_j];
            _results1.push((function() {
              var _k, _len2, _results2;
              _results2 = [];
              for (_k = 0, _len2 = verts.length; _k < _len2; _k++) {
                components = verts[_k];
                _results2.push(this.verts.push(components));
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    } else {
      _results1 = [];
      for (_j = 0, _len1 = newTriangles.length; _j < _len1; _j++) {
        triangles = newTriangles[_j];
        _results1.push(subdivide(newTriangles[i], this.levels - 1));
      }
      return _results1;
    }
  };

  HTM.prototype.bind = function(gl, shaderProgram) {
    gl.bindBuffer(gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, this.VertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.VertexColorBuffer);
    return gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, this.VertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
  };

  HTM.prototype.render = function(gl) {
    return gl.drawArrays(gl.TRIANGLES, 0, this.VertexPositionBuffer.numItems);
  };

  return HTM;

})();
