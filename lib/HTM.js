// Generated by CoffeeScript 1.3.2
var HTM, TextureProxy,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

TextureProxy = (function() {
  /*
  	A TextureProxy uses an already loaded temporary image while
  	another image is loading.
  */

  function TextureProxy(gl, img_url, temp_img_texture) {
    var on_texture_load;
    this.texture = temp_img_texture;
    on_texture_load = function(texture) {
      return this.texture = texture;
    };
    this.initTexture(gl, img_url, on_texture_load);
  }

  /*
  	@function: initTexture
  	@description: Creates a GL_TEXTURE in GPU using the image specified.
  	@param: GL_CONTEXT gl- used to create a texture
  	@param: String image - URL of an image to be used.
  	@param: function load_callback- Use for callbacks when onload is triggered
  			to get the texture, all loaded.
  	@return: Nothing. Use the texture callback.
  */


  TextureProxy.prototype.initTexture = function(gl, image, load_callback) {
    var texture,
      _this = this;
    texture = gl.createTexture();
    texture.image = new Image();
    texture.image.onload = function() {
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      if (load_callback) {
        return load_callback(texture);
      }
    };
    return texture.image.src = image;
  };

  return TextureProxy;

})();

HTM = (function() {

  HTM.VertexPositionBuffer = null;

  HTM.VertexColorBuffer = null;

  HTM.VertexIndexBuffer = null;

  HTM.VertexTextureCoordBuffer = null;

  HTM.VertexNormalBuffer = null;

  HTM.Texture = null;

  HTM.set = null;

  function HTM(gl, Math, type, survey, texture, fits, range) {
    this.gl = gl;
    this.Math = Math;
    this.renderSphere = __bind(this.renderSphere, this);

    this.bindSphere = __bind(this.bindSphere, this);

    this.createSphere = __bind(this.createSphere, this);

    this.initTexture = __bind(this.initTexture, this);

    this.handleLoadedTexture = __bind(this.handleLoadedTexture, this);

    this.getSet = __bind(this.getSet, this);

    this.setFlag = __bind(this.setFlag, this);

    if (type === "sky") {
      this.proj = new Projection(this.Math);
      this.set = false;
      this.proj.init(texture, fits, this, survey);
    } else if (type === "anno") {
      this.initTexture(image);
      this.createSphere([range.maxRA, range.minRA, range.minRA, range.maxRA], [range.minDec, range.minDec, range.maxDec, range.maxDec]);
      this.setFlag();
    }
    /*
    		else if type == "sphere"
    			this.createSphere()
    			this.initTexture(texture)
    */

    return;
  }

  HTM.prototype.setFlag = function() {
    this.set = true;
  };

  HTM.prototype.getSet = function() {
    return this.set;
  };

  HTM.prototype.handleLoadedTexture = function(texture) {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, texture.image);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    return this.gl.bindTexture(this.gl.TEXTURE_2D, null);
  };

  HTM.prototype.initTexture = function(image) {
    var _this = this;
    this.Texture = this.gl.createTexture();
    this.Texture.image = new Image();
    this.Texture.image.onload = function() {
      return _this.handleLoadedTexture(_this.Texture);
    };
    return this.Texture.image.src = image;
  };

  HTM.prototype.createSphere = function(ra, dec) {
    var coord, coords, cosPhi, cosTheta, first, indexData, latNumber, latitudeBands, longNumber, longitudeBands, normalData, phi, radius, second, sinPhi, sinTheta, textureCoordData, theta, u, v, vertexPositionData, x, y, z, _i, _j, _k, _l, _len, _m, _ref, _ref1;
    latitudeBands = 30;
    longitudeBands = 30;
    radius = 1;
    vertexPositionData = [];
    normalData = [];
    textureCoordData = [];
    /* if ra and dec are specified for the sphere, 
    			use them
    */

    if ((ra != null) && (dec != null)) {
      coords = [[ra[0], dec[0]], [ra[1], dec[1]], [ra[2], dec[2]], [ra[3], dec[3]]];
      for (_i = 0, _len = coords.length; _i < _len; _i++) {
        coord = coords[_i];
        phi = (90 - coord[1]) * Math.PI / 180.0;
        theta = 0;
        if (coord[0] > 270) {
          theta = (270 - coord[0] + 360) * Math.PI / 180.0;
        } else {
          theta = (270 - coord[0]) * Math.PI / 180.0;
        }
        sinTheta = Math.sin(theta);
        cosTheta = Math.cos(theta);
        sinPhi = Math.sin(phi);
        cosPhi = Math.cos(phi);
        z = sinPhi * sinTheta;
        y = cosPhi;
        x = sinPhi * cosTheta;
        vertexPositionData.push(radius * x);
        vertexPositionData.push(radius * y);
        vertexPositionData.push(radius * z);
        textureCoordData = [0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0];
      }
      indexData = [2, 3, 0, 1, 2, 0];
    } else {
      radius = 1.1;
      for (latNumber = _j = 0; 0 <= latitudeBands ? _j <= latitudeBands : _j >= latitudeBands; latNumber = 0 <= latitudeBands ? ++_j : --_j) {
        for (longNumber = _k = 0; 0 <= longitudeBands ? _k <= longitudeBands : _k >= longitudeBands; longNumber = 0 <= longitudeBands ? ++_k : --_k) {
          theta = longNumber * 2 * Math.PI / longitudeBands;
          sinTheta = Math.sin(theta);
          cosTheta = Math.cos(theta);
          phi = latNumber * Math.PI / latitudeBands;
          sinPhi = Math.sin(phi);
          cosPhi = Math.cos(phi);
          z = sinPhi * sinTheta;
          y = cosPhi;
          x = sinPhi * cosTheta;
          u = 1 - (longNumber / longitudeBands);
          v = 1 - (latNumber / latitudeBands);
          textureCoordData.push(u);
          textureCoordData.push(v);
          vertexPositionData.push(radius * x);
          vertexPositionData.push(radius * y);
          vertexPositionData.push(radius * z);
        }
      }
      indexData = [];
      for (latNumber = _l = 0, _ref = latitudeBands - 1; 0 <= _ref ? _l <= _ref : _l >= _ref; latNumber = 0 <= _ref ? ++_l : --_l) {
        for (longNumber = _m = 0, _ref1 = longitudeBands - 1; 0 <= _ref1 ? _m <= _ref1 : _m >= _ref1; longNumber = 0 <= _ref1 ? ++_m : --_m) {
          first = (latNumber * (longitudeBands + 1)) + longNumber;
          second = first + longitudeBands + 1;
          indexData.push(first);
          indexData.push(second);
          indexData.push(first + 1);
          indexData.push(second);
          indexData.push(second + 1);
          indexData.push(first + 1);
        }
      }
    }
    this.VertexPositionBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), this.gl.STATIC_DRAW);
    this.VertexPositionBuffer.itemSize = 3;
    this.VertexPositionBuffer.numItems = vertexPositionData.length / 3;
    this.VertexIndexBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.VertexIndexBuffer);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), this.gl.STATIC_DRAW);
    this.VertexIndexBuffer.itemSize = 1;
    this.VertexIndexBuffer.numItems = indexData.length;
    this.VertexTextureCoordBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(textureCoordData), this.gl.STATIC_DRAW);
    this.VertexTextureCoordBuffer.itemSize = 2;
    this.VertexTextureCoordBuffer.numItems = textureCoordData.length / 2;
  };

  HTM.prototype.bindSphere = function(shaderProgram) {
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.Texture);
    this.gl.uniform1i(shaderProgram.samplerUniform, 0);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    this.gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, this.VertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
    this.gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, this.VertexTextureCoordBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.VertexIndexBuffer);
  };

  HTM.prototype.renderSphere = function(renderMode) {
    return this.gl.drawElements(renderMode, this.VertexIndexBuffer.numItems, this.gl.UNSIGNED_SHORT, 0);
  };

  return HTM;

})();
