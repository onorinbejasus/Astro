// Generated by CoffeeScript 1.3.2
var Overlay, TextureProxy, Tile,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

TextureProxy = (function() {
  /*
  	A TextureProxy uses an already loaded temporary image while
  	another image is loading.
  */

  function TextureProxy(gl, img_url, temp_img_texture) {
    var on_texture_load;
    this.texture = temp_img_texture;
    on_texture_load = function(texture) {
      return this.texture = texture;
    };
    this.initTexture(gl, img_url, on_texture_load);
  }

  /*
  	@function: initTexture
  	@description: Creates a GL_TEXTURE in GPU using the image specified.
  	@param: GL_CONTEXT gl- used to create a texture
  	@param: String image - URL of an image to be used.
  	@param: function load_callback- Use for callbacks when onload is triggered
  			to get the texture, all loaded.
  	@return: Nothing. Use the texture callback.
  */


  TextureProxy.prototype.initTexture = function(gl, image, load_callback) {
    var texture,
      _this = this;
    texture = gl.createTexture();
    texture.image = new Image();
    texture.image.onload = function() {
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      if (load_callback) {
        return load_callback(texture);
      }
    };
    return texture.image.src = image;
  };

  return TextureProxy;

})();

Tile = (function() {

  Tile.VertexPositionBuffer = null;

  Tile.VertexColorBuffer = null;

  Tile.VertexIndexBuffer = null;

  Tile.VertexTextureCoordBuffer = null;

  Tile.VertexNormalBuffer = null;

  Tile.Texture = null;

  function Tile(gl, Math, survey, type, texture, fits, range) {
    this.gl = gl;
    this.Math = Math;
    this.getSet = __bind(this.getSet, this);

    this.setFlag = __bind(this.setFlag, this);

    this.render = __bind(this.render, this);

    this.bind = __bind(this.bind, this);

    this.createTile = __bind(this.createTile, this);

    this.initTexture = __bind(this.initTexture, this);

    this.handleLoadedTexture = __bind(this.handleLoadedTexture, this);

    if (type === "sky") {
      this.proj = new Projection(this.Math);
      this.set = false;
      this.proj.init(texture, fits, this, survey);
    } else if (type === "anno") {
      this.initTexture(texture);
      this.createTile([range[1], range[0], range[0], range[1]], [range[3], range[3], range[2], range[2]]);
      this.setFlag();
    }
    return;
  }

  Tile.prototype.handleLoadedTexture = function(texture) {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, texture.image);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    return this.gl.bindTexture(this.gl.TEXTURE_2D, null);
  };

  Tile.prototype.initTexture = function(image) {
    var _this = this;
    this.Texture = this.gl.createTexture();
    this.Texture.image = new Image();
    this.Texture.image.onload = function() {
      return _this.handleLoadedTexture(_this.Texture);
    };
    return this.Texture.image.src = image;
  };

  Tile.prototype.createTile = function(ra, dec) {
    var coord, coords, cosPhi, cosTheta, indexData, normalData, phi, radius, sinPhi, sinTheta, textureCoordData, theta, vertexPositionData, x, y, z, _i, _len;
    radius = 1;
    vertexPositionData = [];
    normalData = [];
    textureCoordData = [];
    /* if ra and dec are specified for the sphere, 
    			use them
    */

    if ((ra != null) && (dec != null)) {
      coords = [[ra[0], dec[0]], [ra[1], dec[1]], [ra[2], dec[2]], [ra[3], dec[3]]];
      for (_i = 0, _len = coords.length; _i < _len; _i++) {
        coord = coords[_i];
        phi = (90 - coord[1]) * Math.PI / 180.0;
        theta = 0;
        if (coord[0] > 270) {
          theta = (270 - coord[0] + 360) * Math.PI / 180.0;
        } else {
          theta = (270 - coord[0]) * Math.PI / 180.0;
        }
        sinTheta = Math.sin(theta);
        cosTheta = Math.cos(theta);
        sinPhi = Math.sin(phi);
        cosPhi = Math.cos(phi);
        z = sinPhi * sinTheta;
        y = cosPhi;
        x = sinPhi * cosTheta;
        vertexPositionData.push(radius * x);
        vertexPositionData.push(radius * y);
        vertexPositionData.push(radius * z);
        textureCoordData = [0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0];
      }
      indexData = [2, 3, 0, 1, 2, 0];
    }
    this.VertexPositionBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), this.gl.STATIC_DRAW);
    this.VertexPositionBuffer.itemSize = 3;
    this.VertexPositionBuffer.numItems = vertexPositionData.length / 3;
    this.VertexIndexBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.VertexIndexBuffer);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), this.gl.STATIC_DRAW);
    this.VertexIndexBuffer.itemSize = 1;
    this.VertexIndexBuffer.numItems = indexData.length;
    this.VertexTextureCoordBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(textureCoordData), this.gl.STATIC_DRAW);
    this.VertexTextureCoordBuffer.itemSize = 2;
    this.VertexTextureCoordBuffer.numItems = textureCoordData.length / 2;
  };

  Tile.prototype.bind = function(shaderProgram) {
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.Texture);
    this.gl.uniform1i(shaderProgram.samplerUniform, 0);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    this.gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, this.VertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
    this.gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, this.VertexTextureCoordBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.VertexIndexBuffer);
  };

  Tile.prototype.render = function(renderMode) {
    return this.gl.drawElements(renderMode, this.VertexIndexBuffer.numItems, this.gl.UNSIGNED_SHORT, 0);
  };

  Tile.prototype.setFlag = function() {
    this.set = true;
  };

  Tile.prototype.getSet = function() {
    return this.set;
  };

  return Tile;

})();

Overlay = (function() {

  Overlay.survey = null;

  Overlay.set = null;

  Overlay.alpha = 1.0;

  Overlay.name = '';

  Overlay.cache = {};

  function Overlay(SkyView, survey, range, name) {
    this.SkyView = SkyView;
    this.setAlpha = __bind(this.setAlpha, this);

    this.createAnnoOverlay = __bind(this.createAnnoOverlay, this);

    this.createSDSSOverlay = __bind(this.createSDSSOverlay, this);

    this.createLSSTOverlay = __bind(this.createLSSTOverlay, this);

    this.createFIRSTOverlay = __bind(this.createFIRSTOverlay, this);

    this.refresh = function() {
      return 0;
    };
    this.survey = survey;
    this.tiles = [];
    this.cache = {};
    if (this.survey === "SDSS") {
      this.createSDSSOverlay();
    } else if (this.survey === "LSST") {
      this.createLSSTOverlay();
    } else if (this.survey === "FIRST") {
      this.createFIRSTOverlay();
    }
    this.alpha = 1.0;
    this.name = name;
    return;
  }

  Overlay.prototype.createFIRSTOverlay = function() {
    var temp_this,
      _this = this;
    this.firstflag = false;
    temp_this = this;
    this.refresh = function() {
      var done, getInfo, range, url;
      range = _this.SkyView.getBoundingBox();
      getInfo = {
        RAMin: range.maxRA,
        RAMax: range.minRA,
        DecMin: range.maxDec,
        DecMax: range.minDec
      };
      url = 'lib/db/remote/SPATIALTREE.php';
      done = function(e) {
        var image, index, name, _i, _len, _results;
        _results = [];
        for (index = _i = 0, _len = e.length; _i < _len; index = ++_i) {
          image = e[index];
          name = image.split("../../images/");
          if (!temp_this.cache[name] && !null) {
            _this.tiles.push(new Tile(_this.SkyView.gl, _this.SkyView.Math, "FIRST", "sky", "" + name[1], "", null));
            _results.push(temp_this.cache[name] = true);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      return $.get(url, getInfo, done, 'json');
    };
    this.refresh();
  };

  Overlay.prototype.createLSSTOverlay = function() {
    var lfile,
      _this = this;
    this.lsstarray = [];
    this.lsstflag = false;
    lfile = new XMLHttpRequest();
    lfile.open('GET', '../../lsstimages/filelist.txt', true);
    lfile.onload = function(e) {
      var image, lines, text, _i, _len, _ref, _results;
      text = lfile.responseText;
      lines = text.split("\n");
      $.each(lines, function(key, val) {
        return _this.lsstarray.push(val);
      });
      _ref = _this.lsstarray;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        image = _ref[_i];
        _results.push(_this.tiles.push(new Tile(_this.SkyView.gl, _this.SkyView.Math, "LSST", "sky", "" + image, "", null)));
      }
      return _results;
    };
    lfile.send();
  };

  Overlay.prototype.createSDSSOverlay = function() {
    var dec, ra, radius,
      _this = this;
    radius = 45;
    if (radius < 1.0) {
      radius = 1.0;
    }
    ra = -this.SkyView.rotation[1];
    dec = -this.SkyView.rotation[0];
    $.ajaxSetup({
      'async': false
    });
    $.getJSON("./lib/webgl/SDSSFieldQuery.php?ra=" + ra + "&dec=" + dec + "&radius=			" + radius + "&zoom=0", function(data) {
      return $.each(data, function(key, val) {
        var fits, fitsFile;
        if (key % 2 === 0) {
          fitsFile = data[key + 1];
          fits = fitsFile.split(".")[0].concat(".").concat(fitsFile.split(".")[1]);
          return _this.tiles.push(new Tile(_this.SkyView.gl, _this.SkyView.Math, "SDSS", "sky", "http://astro.cs.pitt.edu/sdss2degregion00/" + val, "/afs/cs.pitt.edu/projects/admt/web/sites/astro/sdss2degregion00/headtext/" + fits, null));
        }
      });
    });
    return $.ajaxSetup({
      'async': true
    });
  };

  Overlay.prototype.createAnnoOverlay = function(raDec, raMin, raMax, decMin, decMax, color, label) {
    var img, imgURL, range, scale, tempRange, tile,
      _this = this;
    scale = ((-this.SkyView.translation[2] + 1) * 15) * 3600;
    img = '';
    $.ajaxSetup({
      'async': false
    });
    $.ajax({
      type: 'POST',
      url: "./lib/createOverlay.php",
      data: {
        'width': 512,
        'height': 512,
        'RAMin': raMin,
        'RAMax': raMax,
        'DecMin': decMin,
        'DecMax': decMax,
        'scale': 1.8,
        'diam': 1,
        'color': color,
        'table': JSON.stringify(raDec)
      },
      success: function(data) {
        img = data;
      }
    });
    $.ajaxSetup({
      'async': true
    });
    imgURL = "./lib/overlays/" + img;
    range = [raMin, raMax, decMin, decMax];
    tempRange = [0.0, 1.0, 0.0, 1.0];
    tile = new Tile(this.SkyView.gl, this.SkyView.Math, "anno", "anno", imgURL, null, tempRange);
    this.tiles.push(tile);
  };

  Overlay.prototype.setAlpha = function(value) {
    this.alpha = value;
    this.SkyView.render();
  };

  return Overlay;

})();
