// Generated by CoffeeScript 1.3.2
var WebGL,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

WebGL = (function() {

  WebGL.gl = 0;

  WebGL.shaderProgram = 0;

  WebGL.mvMatrix = 0;

  WebGL.mvMatrixStack = null;

  WebGL.pMatrix = 0;

  function WebGL(options) {
    this.preRender = __bind(this.preRender, this);

    this.degToRad = __bind(this.degToRad, this);

    this.setMatrixUniforms = __bind(this.setMatrixUniforms, this);

    this.mvPopMatrix = __bind(this.mvPopMatrix, this);

    this.mvPushMatrix = __bind(this.mvPushMatrix, this);

    this.getMatrices = __bind(this.getMatrices, this);

    this.initShaders = __bind(this.initShaders, this);

    this.getShader = __bind(this.getShader, this);

    this.initGL = __bind(this.initGL, this);
    this.canvas = options.canvas != null ? options.canvas : (this.canvas = document.createElement("canvas"), this.canvas.width = options.clientWidth, this.canvas.height = options.clientHeight, this.canvas.style.backgroundColor = "rgb(0,0,0)", options.appendChild(this.canvas));
    this.initGL();
    this.initShaders();
    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
    this.mvMatrix = mat4.create();
    this.pMatrix = mat4.create();
    this.mvMatrixStack = [];
    return;
  }

  /* initialize the webgl context in the canvas
  */


  WebGL.prototype.initGL = function() {
    try {
      this.gl = WebGLDebugUtils.makeDebugContext(this.canvas.getContext("experimental-webgl"));
      this.gl.viewportWidth = this.canvas.width;
      return this.gl.viewportHeight = this.canvas.height;
    } catch (e) {
      if (!this.gl) {
        return alert("Could not initialize WebGL, sorry :-(");
      }
    }
  };

  /* initialize shaders programs
  */


  WebGL.prototype.getShader = function(id) {
    var shader, source,
      _this = this;
    source = null;
    shader = null;
    if (id === "vertex") {
      $.ajax({
        async: false,
        url: './lib/skyview/shaders/sphere.vs',
        success: function(data) {
          source = $(data).html();
          shader = _this.gl.createShader(_this.gl.VERTEX_SHADER);
        }
      }, {
        dataType: 'html'
      });
    } else {
      $.ajax({
        async: false,
        url: './lib/skyview/shaders/sphere.fs',
        success: function(data) {
          source = $(data).html();
          shader = _this.gl.createShader(_this.gl.FRAGMENT_SHADER);
        },
        dataType: 'html'
      });
    }
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      alert("shaders!");
      alert(this.gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  };

  WebGL.prototype.initShaders = function() {
    var fragmentShader, vertexShader;
    fragmentShader = this.getShader("fragment");
    vertexShader = this.getShader("vertex");
    this.shaderProgram = this.gl.createProgram();
    this.gl.attachShader(this.shaderProgram, vertexShader);
    this.gl.attachShader(this.shaderProgram, fragmentShader);
    this.gl.linkProgram(this.shaderProgram);
    if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
      alert("Could not initialise shaders");
    }
    this.gl.useProgram(this.shaderProgram);
    this.shaderProgram.vertexPositionAttribute = this.gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
    this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);
    this.shaderProgram.textureCoordAttribute = this.gl.getAttribLocation(this.shaderProgram, "aTextureCoord");
    this.gl.enableVertexAttribArray(this.shaderProgram.textureCoordAttribute);
    this.shaderProgram.survey = this.gl.getUniformLocation(this.shaderProgram, "uSurvey");
    this.shaderProgram.pMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uPMatrix");
    this.shaderProgram.mvMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uMVMatrix");
    this.shaderProgram.nMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uNMatrix");
    this.shaderProgram.samplerUniform = this.gl.getUniformLocation(this.shaderProgram, "uSampler");
    this.shaderProgram.alphaUniform = this.gl.getUniformLocation(this.shaderProgram, "alpha");
  };

  WebGL.prototype.getMatrices = function() {
    return [this.mvMatrix, this.pMatrix, [0, 0, this.gl.viewportWidth, this.gl.viewportHeight]];
  };

  WebGL.prototype.mvPushMatrix = function() {
    var copy;
    copy = mat4.create();
    mat4.set(this.mvMatrix, copy);
    this.mvMatrixStack.push(copy);
  };

  WebGL.prototype.mvPopMatrix = function() {
    if (this.mvMatrixStack.length === 0) {
      throw "Invalid popMatrix!";
    }
    this.mvMatrix = this.mvMatrixStack.pop();
  };

  WebGL.prototype.setMatrixUniforms = function() {
    this.gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);
    this.gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);
  };

  WebGL.prototype.degToRad = function(deg) {
    return deg * Math.PI / 180.0;
  };

  WebGL.prototype.preRender = function(rotation, translation) {
    this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    mat4.perspective(45, this.gl.viewportWidth / this.gl.viewportHeight, 0.001, 1000.0, this.pMatrix);
    mat4.identity(this.mvMatrix);
    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
    mat4.translate(this.mvMatrix, translation);
    mat4.rotate(this.mvMatrix, this.degToRad(rotation[0]), [1, 0, 0]);
    mat4.rotate(this.mvMatrix, this.degToRad(rotation[1]), [0, 1, 0]);
    mat4.rotate(this.mvMatrix, this.degToRad(rotation[2]), [0, 0, 1]);
    this.setMatrixUniforms();
  };

  return WebGL;

})();
