// Generated by CoffeeScript 1.3.2
var Map,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Map = (function(_super) {

  __extends(Map, _super);

  Map.VertexPositionBuffer = null;

  Map.VertexColorBuffer = null;

  Map.verts = null;

  Map.color = null;

  function Map(tri, colors, Math, names) {
    this.tri = tri;
    this.colors = colors;
    this.Math = Math;
    this.names = names;
    this.draw = __bind(this.draw, this);

    this.bind = __bind(this.bind, this);

    this.render = __bind(this.render, this);

    this.octaCurse = __bind(this.octaCurse, this);

    this.makeTriangle = __bind(this.makeTriangle, this);

    this.getPoint = __bind(this.getPoint, this);

    octamap.canvas = document.getElementById('octamap');
    Map.__super__.constructor.call(this, octamap);
    this.rotation = [0.0, 0.0, 0.0];
    this.translation = [0.0, 0.0, 0.0];
    this.centers = [];
  }

  Map.prototype.getPoint = function(vert) {
    var denom, p_dp, p_prime;
    denom = Math.abs(vert[0]) + Math.abs(vert[1]) + Math.abs(vert[2]);
    p_prime = [vert[0] / denom, vert[1] / denom, vert[2] / denom];
    p_dp = [0.0, 0.0];
    if (p_prime[1] >= 0) {
      p_dp = [p_prime[0], p_prime[2]];
    } else {
      p_dp = [this.Math.sign(p_prime[0]) * (1 - this.Math.sign(p_prime[2])) * p_prime[2], this.Math.sign(p_prime[2]) * (1 - this.Math.sign(p_prime[0])) * p_prime[0]];
    }
    return p_dp;
  };

  Map.prototype.makeTriangle = function(point, flag) {
    var a, b, c, color, j, k, l, num, x, y, _i, _j, _k, _l, _len, _len1, _len2;
    a = Math.sqrt(Math.pow(point[1][0] - point[2][0], 2) + Math.pow(point[1][1] - point[2][1], 2));
    b = Math.sqrt(Math.pow(point[0][0] - point[2][0], 2) + Math.pow(point[0][1] - point[2][1], 2));
    c = Math.sqrt(Math.pow(point[0][0] - point[1][0], 2) + Math.pow(point[0][1] - point[1][1], 2));
    x = (point[0][0] + point[1][0] + point[2][0]) / (a + b + c);
    y = (point[0][1] + point[1][1] + point[2][1]) / (a + b + c);
    this.centers.push([x, y]);
    this.verts.push(point[0][0] + 1);
    this.verts.push(point[0][1] + 1);
    this.verts.push(-5.0);
    this.verts.push(point[1][0] + 1);
    this.verts.push(point[1][1] + 1);
    this.verts.push(-5.0);
    this.verts.push(point[1][0] + 1);
    this.verts.push(point[1][1] + 1);
    this.verts.push(-5.0);
    this.verts.push(point[2][0] + 1);
    this.verts.push(point[2][1] + 1);
    this.verts.push(-5.0);
    this.verts.push(point[2][0] + 1);
    this.verts.push(point[2][1] + 1);
    this.verts.push(-5.0);
    this.verts.push(point[0][0] + 1);
    this.verts.push(point[0][1] + 1);
    this.verts.push(-5.0);
    color = [[[0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 1.0]]];
    for (num = _i = 0; _i <= 1; num = ++_i) {
      for (_j = 0, _len = color.length; _j < _len; _j++) {
        j = color[_j];
        for (_k = 0, _len1 = j.length; _k < _len1; _k++) {
          k = j[_k];
          for (_l = 0, _len2 = k.length; _l < _len2; _l++) {
            l = k[_l];
            this.color.push(l);
          }
        }
      }
    }
  };

  Map.prototype.octaCurse = function(points, level, name, selected) {
    var it, names, newTri, p0, p1, p2, tri, _i, _len, _results;
    names = ["" + name + "0", "" + name + "1", "" + name + "2", "" + name + "3"];
    it = 0;
    p0 = [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];
    p1 = [(points[1][0] + points[2][0]) / 2, (points[1][1] + points[2][1]) / 2];
    p2 = [(points[2][0] + points[0][0]) / 2, (points[2][1] + points[0][1]) / 2];
    newTri = [[p0, points[1], p1], [points[0], p0, p2], [p2, p1, points[2]], [p0, p1, p2]];
    _results = [];
    for (_i = 0, _len = newTri.length; _i < _len; _i++) {
      tri = newTri[_i];
      if (level === 0) {
        if (names[it++] === selected) {
          _results.push(this.makeTriangle(tri, true));
        } else {
          _results.push(this.makeTriangle(tri, false));
        }
      } else {
        _results.push(this.octaCurse(tri, level - 1, names[it++], selected));
      }
    }
    return _results;
  };

  Map.prototype.render = function(level, selected) {
    var initNames, it, point0, point1, point2, triangle, _i, _len, _ref;
    it = 0;
    this.it = 0;
    initNames = ["S0", "S1", "S2", "S3", "N0", "N1", "N2", "N3"];
    this.verts = [];
    this.color = [];
    _ref = this.tri;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      triangle = _ref[_i];
      point0 = this.getPoint(triangle[0]);
      if (this.names[it].indexOf("S0") !== -1 && this.Math.compare(point0, [0, 0])) {
        point0 = [1, 1];
      }
      if (this.names[it].indexOf("S1") !== -1 && this.Math.compare(point0, [0, 0])) {
        point0 = [-1, 1];
      }
      if (this.names[it].indexOf("S2") !== -1 && this.Math.compare(point0, [0, 0])) {
        point0 = [-1, -1];
      }
      if (this.names[it].indexOf("S3") !== -1 && this.Math.compare(point0, [0, 0])) {
        point0 = [1, -1];
      }
      point1 = this.getPoint(triangle[1]);
      if (this.names[it].indexOf("S0") !== -1 && this.Math.compare(point1, [0, 0])) {
        point1 = [1, 1];
      }
      if (this.names[it].indexOf("S1") !== -1 && this.Math.compare(point1, [0, 0])) {
        point1 = [-1, 1];
      }
      if (this.names[it].indexOf("S2") !== -1 && this.Math.compare(point1, [0, 0])) {
        point1 = [-1, -1];
      }
      if (this.names[it].indexOf("S3") !== -1 && this.Math.compare(point1, [0, 0])) {
        point1 = [1, -1];
      }
      point2 = this.getPoint(triangle[2]);
      if (this.names[it].indexOf("S0") !== -1 && this.Math.compare(point2, [0, 0])) {
        point2 = [1, 1];
      }
      if (this.names[it].indexOf("S1") !== -1 && this.Math.compare(point2, [0, 0])) {
        point2 = [-1, 1];
      }
      if (this.names[it].indexOf("S2") !== -1 && this.Math.compare(point2, [0, 0])) {
        point2 = [-1, -1];
      }
      if (this.names[it++].indexOf("S3") !== -1 && this.Math.compare(point2, [0, 0])) {
        point2 = [1, -1];
      }
      if (level === 0) {
        if (selected === initNames[this.it++]) {
          this.makeTriangle([point0, point1, point2], true);
        } else {
          this.makeTriangle([point0, point1, point2], false);
        }
      } else {
        this.octaCurse([point0, point1, point2], level - 1, initNames[this.it++], selected);
      }
    }
    this.VertexPositionBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.verts), this.gl.STATIC_DRAW);
    this.VertexPositionBuffer.itemSize = 3;
    this.VertexPositionBuffer.numItems = 6;
    this.VertexColorBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexColorBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.color), this.gl.STATIC_DRAW);
    this.VertexColorBuffer.itemSize = 4;
    this.VertexColorBuffer.numItems = 6;
    this.preRender();
    this.bind();
    this.postRender(this.rotation, this.translation);
    this.draw();
  };

  Map.prototype.bind = function() {
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexPositionBuffer);
    this.gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.VertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.VertexColorBuffer);
    this.gl.vertexAttribPointer(this.shaderProgram.vertexColorAttribute, this.VertexColorBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
  };

  Map.prototype.draw = function() {
    this.gl.drawArrays(this.gl.LINES, 0, this.VertexPositionBuffer.numItems);
  };

  return Map;

})(WebGL);
