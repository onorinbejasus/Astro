// Generated by CoffeeScript 1.3.2
var Map,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Map = (function() {

  function Map(tri, colors, Math, names) {
    var octamap;
    this.tri = tri;
    this.colors = colors;
    this.Math = Math;
    this.names = names;
    this.render = __bind(this.render, this);

    this.octaCurse = __bind(this.octaCurse, this);

    this.drawTriangle = __bind(this.drawTriangle, this);

    this.getPoint = __bind(this.getPoint, this);

    octamap = document.getElementById('octamap');
    this.ctx = octamap.getContext('2d');
    this.it = 0;
  }

  Map.prototype.getPoint = function(vert) {
    var denom, p_dp, p_prime;
    denom = Math.abs(vert[0]) + Math.abs(vert[1]) + Math.abs(vert[2]);
    p_prime = [vert[0] / denom, vert[1] / denom, vert[2] / denom];
    p_dp = [0.0, 0.0];
    if (p_prime[1] >= 0) {
      p_dp = [p_prime[0], p_prime[2]];
    } else {
      p_dp = [this.Math.sign(p_prime[0]) * (1 - this.Math.sign(p_prime[2])) * p_prime[2], this.Math.sign(p_prime[2]) * (1 - this.Math.sign(p_prime[0])) * p_prime[0]];
    }
    return p_dp;
  };

  Map.prototype.drawTriangle = function(point, iterator) {
    this.ctx.fillStyle = this.Math.RGBAtoHEX(this.colors[iterator % 8][0]);
    this.ctx.beginPath();
    this.ctx.moveTo((point[0][0] + 1) * 250, (point[0][1] + 1) * 250);
    this.ctx.lineTo((point[1][0] + 1) * 250, (point[1][1] + 1) * 250);
    this.ctx.lineTo((point[2][0] + 1) * 250, (point[2][1] + 1) * 250);
    this.ctx.closePath();
    return this.ctx.fill();
  };

  Map.prototype.octaCurse = function(points, level) {
    var newTri, p0, p1, p2;
    p0 = [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];
    p1 = [(points[1][0] + points[2][0]) / 2, (points[1][1] + points[2][1]) / 2];
    p2 = [(points[2][0] + points[0][0]) / 2, (points[2][1] + points[0][1]) / 2];
    newTri = [[p0, points[1], p1], [points[0], p0, p2], [p2, p1, points[2]], [p0, p1, p2]];
    if (level === 0) {
      this.drawTriangle(newTri[0], this.it++);
      this.drawTriangle(newTri[1], this.it++);
      this.drawTriangle(newTri[2], this.it++);
      return this.drawTriangle(newTri[3], this.it++);
    } else {
      this.octaCurse(newTri[0], level - 1);
      this.octaCurse(newTri[2], level - 1);
      this.octaCurse(newTri[1], level - 1);
      return this.octaCurse(newTri[3], level - 1);
    }
  };

  Map.prototype.render = function(level) {
    var it, point0, point1, point2, triangle, _i, _len, _ref;
    this.ctx.fillStyle = "black";
    this.ctx.fillRect(0, 0, 500, 500);
    it = 0;
    this.it = 0;
    _ref = this.tri;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      triangle = _ref[_i];
      point0 = this.getPoint(triangle[0]);
      if (this.names[it].indexOf("S3") !== -1 && this.Math.compare(point0, [0, 0])) {
        point0 = [1, -1];
      }
      point1 = this.getPoint(triangle[1]);
      if (this.names[it].indexOf("S3") !== -1 && this.Math.compare(point1, [0, 0])) {
        point1 = [1, -1];
      }
      point2 = this.getPoint(triangle[2]);
      if (this.names[it++].indexOf("S3") !== -1 && this.Math.compare(point2, [0, 0])) {
        point2 = [1, -1];
      }
      if (level === 0) {
        this.drawTriangle([point0, point1, point2], this.it++);
      } else {
        this.octaCurse([point0, point1, point2], level - 1, this.it);
      }
    }
  };

  return Map;

})();
