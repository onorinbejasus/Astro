// Generated by CoffeeScript 1.3.2
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

window.WebGL = (function() {

  WebGL.gl = 0;

  WebGL.shaderProgram = 0;

  WebGL.mvMatrix = 0;

  WebGL.mvMatrixStack = null;

  WebGL.pMatrix = 0;

  function WebGL(options) {
    this.postRender = __bind(this.postRender, this);

    this.preRender = __bind(this.preRender, this);

    this.degToRad = __bind(this.degToRad, this);

    this.setMatrixUniforms = __bind(this.setMatrixUniforms, this);

    this.mvPopMatrix = __bind(this.mvPopMatrix, this);

    this.mvPushMatrix = __bind(this.mvPushMatrix, this);

    this.getMatrices = __bind(this.getMatrices, this);

    this.initTexture = __bind(this.initTexture, this);

    this.handleLoadedTexture = __bind(this.handleLoadedTexture, this);

    this.initShaders = __bind(this.initShaders, this);

    this.getShader = __bind(this.getShader, this);

    this.initGL = __bind(this.initGL, this);
    this.canvas = options.canvas != null ? options.canvas : null;
    this.initGL();
    this.initShaders();
    this.gl.clearColor(1.0, 0.0, 0.0, 1.0);
    this.gl.enable(this.gl.DEPTH_TEST);
    this.mvMatrix = mat4.create();
    this.pMatrix = mat4.create();
    this.mvMatrixStack = [];
    return;
  }

  /* initialize the webgl context in the canvas
  */


  WebGL.prototype.initGL = function() {
    try {
      this.gl = this.canvas.getContext("experimental-webgl");
      this.gl.viewportWidth = this.canvas.width;
      return this.gl.viewportHeight = this.canvas.height;
    } catch (e) {
      if (!this.gl) {
        return alert("Could not initialize WebGL, sorry :-(");
      }
    }
  };

  /* initialize shaders programs
  */


  WebGL.prototype.getShader = function(id) {
    var shader, source,
      _this = this;
    source = null;
    shader = null;
    if (id === "vertex") {
      $.ajax({
        async: false,
        url: './src/shaders/sphere.vs',
        success: function(data) {
          source = $(data).html();
          shader = _this.gl.createShader(_this.gl.VERTEX_SHADER);
        }
      }, {
        dataType: 'html'
      });
    } else {
      $.ajax({
        async: false,
        url: './src/shaders/sphere.fs',
        success: function(data) {
          source = $(data).html();
          shader = _this.gl.createShader(_this.gl.FRAGMENT_SHADER);
        },
        dataType: 'html'
      });
    }
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      alert("shaders!");
      alert(this.gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  };

  WebGL.prototype.initShaders = function() {
    var fragmentShader, vertexShader;
    fragmentShader = this.getShader("fragment");
    vertexShader = this.getShader("vertex");
    this.shaderProgram = this.gl.createProgram();
    this.gl.attachShader(this.shaderProgram, vertexShader);
    this.gl.attachShader(this.shaderProgram, fragmentShader);
    this.gl.linkProgram(this.shaderProgram);
    if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
      alert("Could not initialise shaders");
    }
    this.gl.useProgram(this.shaderProgram);
    this.shaderProgram.vertexPositionAttribute = this.gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
    this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);
    this.shaderProgram.textureCoordAttribute = this.gl.getAttribLocation(this.shaderProgram, "aTextureCoord");
    this.gl.enableVertexAttribArray(this.shaderProgram.textureCoordAttribute);
    this.shaderProgram.vertexNormalAttribute = this.gl.getAttribLocation(this.shaderProgram, "aVertexNormal");
    this.gl.enableVertexAttribArray(this.shaderProgram.vertexNormalAttribute);
    this.shaderProgram.pMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uPMatrix");
    this.shaderProgram.mvMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uMVMatrix");
    this.shaderProgram.nMatrixUniform = this.gl.getUniformLocation(this.shaderProgram, "uNMatrix");
    this.shaderProgram.samplerUniform = this.gl.getUniformLocation(this.shaderProgram, "uSampler");
  };

  WebGL.prototype.handleLoadedTexture = function(texture) {
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, gl.RGBA, this.gl.UNSIGNED_BYTE, texture.image);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
  };

  WebGL.prototype.initTexture = function(texture, image) {
    var _this = this;
    texture = gl.createTexture();
    texture.image = new Image();
    texture.image.onload = function() {
      return handleLoadedTexture(texture);
    };
    neheTexture.image.src = image;
  };

  WebGL.prototype.getMatrices = function() {
    return [this.mvMatrix, this.pMatrix, [0, 0, this.gl.viewportWidth, this.gl.viewportHeight]];
  };

  WebGL.prototype.mvPushMatrix = function() {
    var copy;
    copy = mat4.create();
    mat4.set(this.mvMatrix, copy);
    this.mvMatrixStack.push(copy);
  };

  WebGL.prototype.mvPopMatrix = function() {
    if (this.mvMatrixStack.length === 0) {
      throw "Invalid popMatrix!";
    }
    this.mvMatrix = this.mvMatrixStack.pop();
  };

  WebGL.prototype.setMatrixUniforms = function() {
    this.gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);
    this.gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);
  };

  WebGL.prototype.degToRad = function(deg) {
    return deg * Math.PI / 180.0;
  };

  WebGL.prototype.preRender = function() {
    this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    mat4.perspective(45, this.gl.viewportWidth / this.gl.viewportHeight, 0.0001, 100.0, this.pMatrix);
    mat4.identity(this.mvMatrix);
  };

  WebGL.prototype.postRender = function(rotation, translation) {
    this.gl.clearColor(1.0, 0.0, 0.0, 1.0);
    mat4.translate(this.mvMatrix, translation);
    mat4.rotate(this.mvMatrix, this.degToRad(rotation[0]), [1, 0, 0]);
    mat4.rotate(this.mvMatrix, this.degToRad(rotation[1]), [0, 1, 0]);
    mat4.rotate(this.mvMatrix, this.degToRad(rotation[2]), [0, 0, 1]);
    this.setMatrixUniforms();
  };

  return WebGL;

})();
