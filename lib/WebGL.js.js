// Generated by CoffeeScript 1.3.2
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

window.WebGL = (function() {

  WebGL.gl = 0;

  WebGL.shaderProgram = 0;

  WebGL.mvMatrix = mat4.create();

  WebGL.mvMatrixStack = [];

  WebGL.pMatrix = mat4.create();

  function WebGL(options) {
    this.render = __bind(this.render, this);

    this.preRender = __bind(this.preRender, this);

    this.setMatrixUniforms = __bind(this.setMatrixUniforms, this);

    this.mvPopMatrix = __bind(this.mvPopMatrix, this);

    this.mvPushMatrix = __bind(this.mvPushMatrix, this);

    this.initShaders = __bind(this.initShaders, this);

    this.getShader = __bind(this.getShader, this);

    this.initGL = __bind(this.initGL, this);
    this.canvas = options.canvas != null ? options.canvas : null;
    initGL();
    initShaders();
    initBuffers();
  }

  /* initialize the webgl context in the canvas
  */


  WebGL.prototype.initGL = function() {
    try {
      this.gl = this.canvas.getContext("experimental-webgl");
      this.gl.viewportWidth = this.canvas.width;
      return this.gl.viewportHeight = this.canvas.height;
    } catch (e) {
      if (!this.gl) {
        return alert("Could not initialise WebGL, sorry :-(");
      }
    }
  };

  /* initialize shaders programs
  */


  WebGL.prototype.getShader = function(id) {
    var source;
    source = null;
    if (id === "vertex") {
      $.ajax({
        async: false,
        url: './shader.vs',
        success: {
          data: function() {
            var shader;
            source = $(data).html();
            return shader = this.gl.createShader(this.gl.VERTEX_SHADER);
          }
        }
      }, {
        dataType: 'html'
      });
    } else {
      $.ajax({
        async: false,
        url: './shader.fs',
        success: {
          data: function() {
            var shader;
            source = $(data).html();
            return shader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
          },
          dataType: 'html'
        }
      });
    }
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      alert(this.gl.getShaderInfoLog(shader));
      return null;
    }
    return shaders;
  };

  WebGL.prototype.initShaders = function() {
    var fragmentShader, shaderProgram, vertexShader;
    fragmentShader = getShader(this.gl, "shader-fs");
    vertexShader = getShader(this.gl, "shader-vs");
    shaderProgram = this.gl.createProgram();
    this.gl.attachShader(this.shaderProgram, vertexShader);
    this.gl.attachShader(this.shaderProgram, fragmentShader);
    this.gl.linkProgram(this.shaderProgram);
    if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
      alert("Could not initialise shaders");
    }
    this.gl.useProgram(shaderProgram);
    this.shaderProgram.vertexPositionAttribute = this.gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
    this.gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);
    this.shaderProgram.vertexColorAttribute = this.gl.getAttribLocation(this.shaderProgram, "aVertexColor");
    this.gl.enableVertexAttribArray(this.shaderProgram.vertexColorAttribute);
    this.shaderProgram.pMatrixUniform = gl.getUniformLocation(this.shaderProgram, "uPMatrix");
    return this.shaderProgram.mvMatrixUniform = gl.getUniformLocation(this.shaderProgram, "uMVMatrix");
  };

  WebGL.prototype.mvPushMatrix = function() {
    var copy;
    copy = mat4.create();
    mat4.set(this.mvMatrix, copy);
    return this.mvMatrixStack.push(copy);
  };

  WebGL.prototype.mvPopMatrix = function() {
    var mvMatrix;
    if (mvMatrixStack.length === 0) {
      throw "Invalid popMatrix!";
    }
    return mvMatrix = mvMatrixStack.pop();
  };

  WebGL.prototype.setMatrixUniforms = function() {
    this.gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);
    return this.gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);
  };

  WebGL.prototype.preRender = function() {
    this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);
    this.gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    mat4.perspective(45, this.gl.viewportWidth / this.gl.viewportHeight, 0.1, 100.0, this.pMatrix);
    return mat4.identity(this.mvMatrix);
  };

  WebGL.prototype.render = function() {
    return setMatrixUniforms();
  };

  return WebGL;

})();
