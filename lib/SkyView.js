// Generated by CoffeeScript 1.3.2
var SkyView,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

SkyView = (function(_super) {

  __extends(SkyView, _super);

  SkyView.HTM = 0;

  SkyView.rotation = null;

  SkyView.translation = null;

  SkyView.renderMode = 0;

  SkyView.Math = null;

  SkyView.it = 0;

  function SkyView(options) {
    this.mousePress = __bind(this.mousePress, this);

    this.keyPressed = __bind(this.keyPressed, this);

    this.render = __bind(this.render, this);

    this.octaCurse = __bind(this.octaCurse, this);

    this.drawTriangle = __bind(this.drawTriangle, this);

    this.getPoint = __bind(this.getPoint, this);

    this.getLevel = __bind(this.getLevel, this);

    this.getScale = __bind(this.getScale, this);

    var octamap;
    SkyView.__super__.constructor.call(this, options);
    this.Math = new math();
    this.level = 0;
    this.HTM = new HTM(this.level, this.gl, this.Math);
    this.rotation = [0.0, 0.0, 0.0];
    this.translation = [0.0, 0.0, 0.0];
    this.renderMode = this.gl.TRIANGLES;
    this.colors = this.HTM.getColors();
    octamap = document.getElementById('octamap');
    this.ctx = octamap.getContext('2d');
    this.render();
  }

  SkyView.prototype.getScale = function() {
    return (180.0 * (1.0 - this.translation[2])) / 2;
  };

  SkyView.prototype.getLevel = function() {
    return 180.0 / (Math.pow(2, this.level + 1));
  };

  SkyView.prototype.getPoint = function(vert) {
    var denom, p_dp, p_prime;
    denom = Math.abs(vert[0]) + Math.abs(vert[1]) + Math.abs(vert[2]);
    p_prime = [vert[0] / denom, vert[1] / denom, vert[2] / denom];
    p_dp = [0.0, 0.0];
    if (p_prime[1] >= 0) {
      p_dp = [p_prime[0], p_prime[2]];
    } else {
      p_dp = [this.Math.sign(p_prime[0]) * (1 - this.Math.sign(p_prime[2])) * p_prime[2], this.Math.sign(p_prime[2]) * (1 - this.Math.sign(p_prime[0])) * p_prime[0]];
    }
    return p_dp;
  };

  SkyView.prototype.drawTriangle = function(point, iterator) {
    this.ctx.fillStyle = this.Math.RGBAtoHEX(this.colors[iterator][0]);
    this.ctx.beginPath();
    this.ctx.moveTo((point[0][0] + 1) * 250, (point[0][1] + 1) * 250);
    this.ctx.lineTo((point[1][0] + 1) * 250, (point[1][1] + 1) * 250);
    this.ctx.lineTo((point[2][0] + 1) * 250, (point[2][1] + 1) * 250);
    this.ctx.closePath();
    return this.ctx.fill();
  };

  SkyView.prototype.octaCurse = function(points, level) {
    var newTri, p0, p1, p2;
    p0 = [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];
    p1 = [(points[1][0] + points[2][0]) / 2, (points[1][1] + points[2][1]) / 2];
    p2 = [(points[2][0] + points[0][0]) / 2, (points[2][1] + points[0][1]) / 2];
    newTri = [[p2, p1, points[2]], [p0, points[1], p1], [points[0], p0, p2], [p0, p1, p2]];
    if (level === 0) {
      this.drawTriangle(newTri[0], this.it++);
      this.drawTriangle(newTri[1], this.it++);
      this.drawTriangle(newTri[2], this.it++);
      return this.drawTriangle(newTri[3], this.it++);
    } else {
      this.octaCurse(newTri[0], level - 1);
      this.octaCurse(newTri[1], level - 1);
      this.octaCurse(newTri[2], level - 1);
      return this.octaCurse(newTri[3], level - 1);
    }
  };

  SkyView.prototype.render = function() {
    var it, names, point0, point1, point2, tri, triangle, _i, _len;
    this.preRender();
    this.HTM.bind(this.gl, this.shaderProgram);
    this.postRender(this.rotation, this.translation);
    this.HTM.render(this.gl, this.renderMode);
    this.it = 0;
    tri = this.HTM.getInitTriangles();
    names = this.HTM.getNames();
    this.ctx.fillStyle = "black";
    this.ctx.fillRect(0, 0, 500, 500);
    it = 0;
    for (_i = 0, _len = tri.length; _i < _len; _i++) {
      triangle = tri[_i];
      point0 = this.getPoint(triangle[0]);
      if (names[it].indexOf("S3") !== -1 && this.Math.compare(point0, [0, 0])) {
        point0 = [1, -1];
      }
      point1 = this.getPoint(triangle[1]);
      if (names[it].indexOf("S3") !== -1 && this.Math.compare(point1, [0, 0])) {
        point1 = [1, -1];
      }
      point2 = this.getPoint(triangle[2]);
      if (names[it++].indexOf("S3") !== -1 && this.Math.compare(point2, [0, 0])) {
        point2 = [1, -1];
      }
      console.log("point0: ", point0);
      console.log("point1: ", point1);
      console.log("point2: ", point2);
      console.log("triangle points: ", names, triangle);
      if (this.level === 0) {
        this.drawTriangle([point0, point1, point2], this.it++);
      } else {
        this.octaCurse([point0, point1, point2], this.level - 1, this.it);
      }
    }
  };

  SkyView.prototype.keyPressed = function(key) {
    switch (String.fromCharCode(key.which)) {
      case 'i':
        this.rotation[0]++;
        break;
      case 'k':
        this.rotation[0]--;
        break;
      case 'l':
        this.rotation[1]++;
        break;
      case 'j':
        this.rotation[1]--;
        break;
      case 'w':
        this.translation[2] += 0.1;
        break;
      case 's':
        this.translation[2] -= 0.1;
        break;
      case '0':
        this.HTM = new HTM(0, this.gl, this.Math);
        this.level = 0;
        this.ctx.fillStyle = "red";
        this.ctx.fillRect(0, 0, 500, 500);
        break;
      case '1':
        this.HTM = new HTM(1, this.gl, this.Math);
        this.level = 1;
        this.ctx.fillStyle = "red";
        this.ctx.fillRect(0, 0, 500, 500);
        break;
      case '2':
        this.HTM = new HTM(2, this.gl, this.Math);
        this.level = 2;
        this.ctx.fillStyle = "red";
        this.ctx.fillRect(0, 0, 500, 500);
        break;
      case '3':
        this.HTM = new HTM(3, this.gl, this.Math);
        this.level = 3;
        this.ctx.fillStyle = "red";
        this.ctx.fillRect(0, 0, 500, 500);
        break;
      case '4':
        this.HTM = new HTM(4, this.gl, this.Math);
        this.level = 4;
        this.ctx.fillStyle = "red";
        this.ctx.fillRect(0, 0, 500, 500);
        break;
      case '5':
        this.HTM = new HTM(5, this.gl, this.Math);
        this.level = 5;
        this.ctx.fillStyle = "red";
        this.ctx.fillRect(0, 0, 500, 500);
        break;
      case '6':
        this.HTM = new HTM(6, this.gl, this.Math);
        this.level = 6;
        this.ctx.fillStyle = "red";
        this.ctx.fillRect(0, 0, 500, 500);
        break;
      case '7':
        this.HTM = new HTM(7, this.gl, this.Math);
        this.level = 7;
        this.ctx.fillStyle = "red";
        this.ctx.fillRect(0, 0, 500, 500);
        break;
      case '8':
        this.HTM = new HTM(8, this.gl, this.Math);
        this.level = 8;
        this.ctx.fillStyle = "red";
        this.ctx.fillRect(0, 0, 500, 500);
    }
    this.render();
  };

  SkyView.prototype.mousePress = function(key) {
    var dir, far, inverse, it, matrices, names, near, origin, success, tri, triangle, _i, _len;
    matrices = this.getMatrices();
    near = [];
    far = [];
    success = GLU.unProject(key.x, this.gl.viewportHeight - key.y, 0.0, matrices[0], matrices[1], matrices[2], near);
    success = GLU.unProject(key.x, this.gl.viewportHeight - key.y, 1.0, matrices[0], matrices[1], matrices[2], far);
    dir = this.Math.subtract(far, near);
    origin = [0.0, 0.0, 0.0, 1.0];
    inverse = mat4.set(matrices[0], mat4.create());
    inverse = mat4.inverse(inverse);
    origin = this.Math.multiply(origin, inverse);
    dir = this.Math.norm(dir);
    tri = this.HTM.getTriangles();
    names = this.HTM.getNames();
    it = -1;
    for (_i = 0, _len = tri.length; _i < _len; _i++) {
      triangle = tri[_i];
      it = it + 1;
      if (this.Math.intersectTri(origin, dir, triangle)) {
        alert(names[it]);
        break;
      } else {
        console.log(triangle);
      }
    }
  };

  return SkyView;

})(WebGL);
