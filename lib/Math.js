// Generated by CoffeeScript 1.3.1
(function() {
  var math,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  math = (function() {

    math.name = 'math';

    function math() {
      this.rotate = __bind(this.rotate, this);

      this.arg = __bind(this.arg, this);

      this.RGBAtoHEX = __bind(this.RGBAtoHEX, this);

      this.intersectTri = __bind(this.intersectTri, this);

      this.compare = __bind(this.compare, this);

      this.multiply = __bind(this.multiply, this);

      this.sign = __bind(this.sign, this);

      this.cross = __bind(this.cross, this);

      this.dot = __bind(this.dot, this);

      this.add = __bind(this.add, this);

      this.mult = __bind(this.mult, this);

      this.subtract = __bind(this.subtract, this);

      this.norm = __bind(this.norm, this);

      this.magnitude = __bind(this.magnitude, this);

    }

    math.prototype.magnitude = function(v1, v2) {
      return Math.pow(Math.pow(v1[0] + v2[0], 2) + Math.pow(v1[1] + v2[1], 2) + Math.pow(v1[2] + v2[2], 2), 0.5);
    };

    math.prototype.norm = function(v1) {
      var mag;
      mag = Math.sqrt(Math.pow(v1[0], 2) + Math.pow(v1[1], 2) + Math.pow(v1[2], 2) + 1);
      return [v1[0] / mag, v1[1] / mag, v1[2] / mag];
    };

    math.prototype.subtract = function(v1, v2) {
      if (v1.length === !v2.length) {
        return null;
      } else if (v1.length === 2) {
        return [v1[0] - v2[0], v1[1] - v2[1]];
      } else if (v1.length === 3) {
        return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
      } else if (v1.length === 4) {
        return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2], v1[3] - v2[3]];
      }
    };

    math.prototype.mult = function(v1, scale) {
      if (v1.length === 2) {
        return [v1[0] * scale, v1[1] * scale];
      } else if (v1.length === 3) {
        return [v1[0] * scale, v1[1] * scale, v1[2] * scale];
      } else if (v1.length === 4) {
        return [v1[0] * scale, v1[1] * scale, v1[2] * scale, v1[3] * scale];
      }
    };

    math.prototype.add = function(v1, v2) {
      if (v1.length === !v2.length) {
        return null;
      } else if (v1.length === 2) {
        return [v1[0] + v2[0], v1[1] + v2[1]];
      } else if (v1.length === 3) {
        return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
      } else if (v1.length === 4) {
        return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2], v1[3] + v2[3]];
      }
    };

    math.prototype.dot = function(v1, v2) {
      if (v1.length === !v2.length) {
        return null;
      } else if (v1.length === 2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
      } else if (v1.length === 3) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
      } else if (v1.length === 4) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3];
      }
    };

    math.prototype.cross = function(v1, v2) {
      return [v1[1] * v2[2] - v1[2] * v2[1], v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0]];
    };

    math.prototype.sign = function(a) {
      if (a > 0) {
        return 1;
      } else if (a < 0) {
        return -1;
      } else {
        return 0;
      }
    };

    math.prototype.multiply = function(a, b) {
      var c;
      c = [0, 0, 0, 0];
      c[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + b[12];
      c[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + b[13];
      c[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + b[14];
      c[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + b[15];
      return c;
    };

    math.prototype.compare = function(a, b) {
      var i, j, _i, _j, _len, _len1;
      if (a.length !== b.length) {
        return false;
      }
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        i = a[_i];
        for (_j = 0, _len1 = b.length; _j < _len1; _j++) {
          j = b[_j];
          if (i !== j) {
            return false;
          }
        }
      }
      return true;
    };

    math.prototype.intersectTri = function(orig, dir, verts) {
      var M, a, akjb, b, betatop, blkc, c, dheg, eihf, gammatop, gfdi, jcal, t, ttop, u, v;
      a = verts[0];
      b = verts[1];
      c = verts[2];
      eihf = (a[1] - c[1]) * dir[2] - dir[1] * (a[2] - c[2]);
      gfdi = dir[0] * (a[2] - c[2]) - (a[0] - c[0]) * dir[2];
      dheg = (a[0] - c[0]) * dir[1] - (a[1] - c[1]) * dir[0];
      M = (a[0] - b[0]) * eihf + (a[1] - b[1]) * gfdi + (a[2] - b[2]) * dheg;
      akjb = (a[0] - b[0]) * (a[1] - orig[1]) - (a[0] - orig[0]) * (a[1] - b[1]);
      jcal = (a[0] - orig[0]) * (a[2] - b[2]) - (a[0] - b[0]) * (a[2] - orig[2]);
      blkc = (a[1] - b[1]) * (a[2] - orig[2]) - (a[1] - orig[1]) * (a[2] - b[2]);
      betatop = (a[0] - orig[0]) * eihf + (a[1] - orig[1]) * gfdi + (a[2] - orig[2]) * dheg;
      gammatop = dir[2] * akjb + dir[1] * jcal + dir[0] * blkc;
      ttop = (a[2] - c[2]) * akjb + (a[1] - c[1]) * jcal + (a[0] - c[0]) * blkc;
      u = betatop / M;
      v = gammatop / M;
      t = ttop / M;
      if (u < 0.0 || u > 1.0 || t >= 0) {
        return false;
      } else {
        if (v < 0.0 || u + v > 1.0) {
          return false;
        } else {
          console.log("t", t);
          console.log("u,v", u, v);
          return true;
        }
      }
      return false;
    };

    math.prototype.RGBAtoHEX = function(color) {
      var alpha, blue, green, hex, red;
      color = this.mult(color, 255);
      red = parseInt(color[0]).toString(16);
      green = parseInt(color[1]).toString(16);
      blue = parseInt(color[2]).toString(16);
      alpha = parseInt(color[3]).toString(16);
      if (red.length === 1) {
        red = "" + red + "0";
      }
      if (green.length === 1) {
        green = "" + green + "0";
      }
      if (blue.length === 1) {
        blue = "" + blue + "0";
      }
      if (alpha.length === 1) {
        alpha = "" + alpha + "0";
      }
      return hex = "#" + red + green + blue;
    };

    math.prototype.arg = function(x, y) {
      if (x > 0) {
        return Math.atan(y / x);
      } else if (x === 0 && y > 0) {
        return Math.PI / 2.0;
      } else if (x === 0 && y < 0) {
        return -Math.PI / 2.0;
      } else if (x < 0 && y >= 0) {
        return Math.PI + Math.atan(y / x);
      } else if (x < 0 && y < 0) {
        return -Math.PI + Math.atan(y / x);
      }
    };

    math.prototype.rotate = function(x) {
      return [x[1], x[0]];
    };

    return math;

  })();

}).call(this);
