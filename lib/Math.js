// Generated by CoffeeScript 1.3.2
var math,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

math = (function() {

  function math() {
    this.intersectTri = __bind(this.intersectTri, this);

    this.unProj = __bind(this.unProj, this);

    this.cross = __bind(this.cross, this);

    this.dot = __bind(this.dot, this);

    this.add = __bind(this.add, this);

    this.subtract = __bind(this.subtract, this);

    this.norm = __bind(this.norm, this);

    this.magnitude = __bind(this.magnitude, this);

  }

  math.prototype.magnitude = function(v1, v2) {
    return Math.pow(Math.pow(v1[0] + v2[0], 2) + Math.pow(v1[1] + v2[1], 2) + Math.pow(v1[2] + v2[2], 2), 0.5);
  };

  math.prototype.norm = function(v1) {
    var mag;
    mag = Math.sqrt(Math.pow(v1[0], 2) + Math.pow(v1[1], 2) + Math.pow(v1[2], 2));
    return [v1[0] / mag, v1[1] / mag, v1[2] / mag];
  };

  math.prototype.subtract = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    } else if (v1.length === 3) {
      return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
    } else if (v1.length === 4) {
      return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2], v1[3] - v2[3]];
    }
  };

  math.prototype.add = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return [v1[0] + v2[0], v1[1] + v2[1]];
    } else if (v1.length === 3) {
      return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
    } else if (v1.length === 4) {
      return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2], v1[3] + v2[3]];
    }
  };

  math.prototype.dot = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    } else if (v1.length === 3) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    } else if (v1.length === 4) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3];
    }
  };

  math.prototype.cross = function(v1, v2) {
    return [v1[1] * v2[2] - v1[2] * v2[1], v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0]];
  };

  math.prototype.unProj = function(winX, winY, winZ, mod_mat, proj_mat, viewport) {
    var inf, m, out;
    inf = [];
    m = mat4.set(mod_mat, mat4.create());
    mat4.inverse(m, m);
    mat4.multiply(proj_mat, m, m);
    mat4.inverse(m, m);
    inf.push((winX - viewport[0]) / viewport[2] * 2.0 - 1.0);
    inf.push((winY - viewport[1]) / viewport[3] * 2.0 - 1.0);
    inf.push(2.0 * winZ - 1.0);
    inf.push(1.0);
    out = [0, 0, 0, 0];
    mat4.multiplyVec4(m, inf, out);
    if (out[3] === 0) {
      return null;
    }
    out[3] = 1.0 / out[3];
    return [out[0] * out[3], out[1] * out[3], out[2] * out[3]];
  };

  math.prototype.intersectTri = function(position, direction, triangle, near, far) {
    var E_1, E_2, P, Q, T, det, t, u, v, v_0, v_1, v_2;
    console.log("dir: ", direction);
    console.log("tri: ", triangle);
    v_0 = triangle[2];
    v_1 = triangle[1];
    v_2 = triangle[0];
    console.log("vertices: ", v_0, v_1, v_2);
    E_1 = this.subtract(v_1, v_0);
    E_2 = this.subtract(v_2, v_0);
    console.log("e1,e2: ", E_1, E_2);
    T = this.subtract(position, v_0);
    console.log("T: ", T);
    Q = this.cross(T, E_1);
    P = this.cross(direction, E_2);
    console.log("q,p: ", Q, P);
    det = this.dot(P, E_1);
    if (det > -0.00001 && det < 0.00001) {
      return "Not intersection";
    }
    det = 1.0 / det;
    console.log("det: ", det);
    t = det * this.dot(Q, E_2);
    u = det * this.dot(P, T);
    v = det * this.dot(Q, direction);
    console.log("t,u,v: ", t, u, v);
    if (u < 0.0 || u > 1.0) {
      return "Not intersected!";
    }
    if (v < 0.0 || u + v > 1.0) {
      return "Not intersected!";
    }
    if (t > 0.00001) {
      return "Hit!";
    } else {
      return "Not intersected!";
    }
  };

  return math;

})();
