// Generated by CoffeeScript 1.3.3
var math,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

math = (function() {

  function math() {
    this.intersectTri = __bind(this.intersectTri, this);

    this.unProj = __bind(this.unProj, this);

    this.cross = __bind(this.cross, this);

    this.dot = __bind(this.dot, this);

    this.add = __bind(this.add, this);

    this.subtract = __bind(this.subtract, this);

    this.norm = __bind(this.norm, this);

    this.magnitude = __bind(this.magnitude, this);

  }

  math.prototype.magnitude = function(v1, v2) {
    return Math.pow(Math.pow(v1[0] + v2[0], 2) + Math.pow(v1[1] + v2[1], 2) + Math.pow(v1[2] + v2[2], 2), 0.5);
  };

  math.prototype.norm = function(v1) {
    var mag;
    mag = Math.sqrt(Math.pow(v1[0], 2) + Math.pow(v1[1], 2) + Math.pow(v1[2], 2));
    return [v1[0] / mag, v1[1] / mag, v1[2] / mag];
  };

  math.prototype.subtract = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    } else if (v1.length === 3) {
      return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
    } else if (v1.length === 4) {
      return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2], v1[3] - v2[3]];
    }
  };

  math.prototype.add = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return [v1[0] + v2[0], v1[1] + v2[1]];
    } else if (v1.length === 3) {
      return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
    } else if (v1.length === 4) {
      return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2], v1[3] + v2[3]];
    }
  };

  math.prototype.dot = function(v1, v2) {
    if (v1.length === !v2.length) {
      return null;
    } else if (v1.length === 2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    } else if (v1.length === 3) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    } else if (v1.length === 4) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3];
    }
  };

  math.prototype.cross = function(v1, v2) {
    return [v1[1] * v2[2] - v1[2] * v2[1], v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0]];
  };

  math.prototype.unProj = function(winX, winY, winZ, mod_mat, proj_mat, viewport) {
    var inf, m, out;
    inf = [];
    m = mat4.set(mod_mat, mat4.create());
    mat4.inverse(m, m);
    mat4.multiply(proj_mat, m, m);
    mat4.inverse(m, m);
    inf.push((winX - viewport[0]) / viewport[2] * 2.0 - 1.0);
    inf.push((winY - viewport[1]) / viewport[3] * 2.0 - 1.0);
    inf.push(2.0 * winZ - 1.0);
    inf.push(1.0);
    out = [0, 0, 0, 0];
    mat4.multiplyVec4(m, inf, out);
    if (out[3] === 0) {
      return null;
    }
    out[3] = 1.0 / out[3];
    return [out[0] * out[3], out[1] * out[3], out[2] * out[3]];
  };

<<<<<<< HEAD
  math.prototype.intersectTri = function(position, direction, triangle) {
    var E_1, E_2, P, Q, T, det, t, u, v, v_0, v_1, v_2;
    v_0 = triangle[2];
    v_1 = triangle[1];
    v_2 = triangle[0];
=======
  math.prototype.intersectTri = function(position, direction, triangle, near, far) {
    var E_1, E_2, P, Q, T, det, t, u, v, v_0, v_1, v_2;
    console.log("dir: ", direction);
    console.log("near: ", near);
    console.log("far: ", far);
    console.log("normnear: ", this.norm(near));
    console.log("normfar: ", this.norm(far));
    v_0 = triangle[0];
    v_1 = triangle[1];
    v_2 = triangle[2];
    console.log("vertices: ", v_0, v_1, v_2);
>>>>>>> 1d9be06278186de802377c6191ebcc7dc37ba038
    E_1 = this.subtract(v_1, v_0);
    E_2 = this.subtract(v_2, v_0);
    console.log("e1,e2: ", E_1, E_2);
    T = this.subtract(position, v_0);
    console.log("T: ", T);
    Q = this.cross(T, E_1);
    P = this.cross(direction, E_2);
<<<<<<< HEAD
    det = 1.0 / this.dot(P, E_1);
    t = det * this.dot(Q, E_2);
    u = det * this.dot(P, T);
    v = det * this.dot(Q, direction);
    return [t, u, v];
=======
    console.log("q,p: ", Q, P);
    det = 1.0 / this.dot(P, E_1);
    console.log("det: ", det);
    t = det * this.dot(Q, E_2);
    u = det * this.dot(P, T);
    v = det * this.dot(Q, direction);
    console.log("t,u,v: ", t, u, v);
    if (u >= 0.0 && v >= 0.0 && (u + v) <= 1.0) {
      return [t, u, v];
    } else {
      return "Not intersected!";
    }
>>>>>>> 1d9be06278186de802377c6191ebcc7dc37ba038
  };

  return math;

})();
