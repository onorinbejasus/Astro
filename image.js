// Generated by IcedCoffeeScript 1.3.1b
var ImageLoader, Overlay, Pane, SDSSOverlay,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

ImageLoader = (function() {

  ImageLoader.name = 'ImageLoader';

  /*
    Image loader is used to load multiple images at once, then call a function when they are all loaded.
    TODO:Needs to be a singleton.
    TODO: Needs to cache, as in an object
  */


  function ImageLoader() {
    this.onFullLoad = __bind(this.onFullLoad, this);
    this.imageHolder = {};
    this.loadStack = 0;
    this.count = 0;
    this.start = false;
    this.loadedFunc = function() {
      return this.start = false;
    };
  }

  /*
    Parameter: image url (DO NOT PUT AN ACTUAL IMAGE ELEMENT IN, Only the URL)
              action: a function that will be called when the image is done loading.  
    returns: Nothing
    Push an image to the image stack.
  */


  ImageLoader.prototype.pushImage = function(imgUrl, action) {
    var newImg,
      _this = this;
    if ((this.imageHolder[imgUrl] != null)) {} else {
      newImg = document.createElement("img");
      this.loadStack += 1;
      this.count += 1;
      newImg.src = imgUrl;
      newImg.onload = function() {
        _this.loadStack -= 1;
        return action(newImg);
      };
      return this.imageHolder[imgUrl] = newImg;
    }
  };

  /*
    Will set a flag that allows the loading to 'begin'. Technically, it starts when you push an image onto the stack
    but this will make it so that the onFullLoaded will be called, since it knows all pushing is done.
  */


  ImageLoader.prototype.startLoad = function() {
    this.start = true;
    if (this.loadedStack === 0 && this.start) return this.loadedFunc();
  };

  /*
    returns: BOOLEAN
    will check if all the images are loaded.
  */


  ImageLoader.prototype.imagesLoaded = function() {
    return this.loadStack === 0;
  };

  /*
    Returns: float
    will be between 1 and 100 of percent of images loaded.
  */


  ImageLoader.prototype.percentLoaded = function() {
    return 100.0 * (this.count - this.loadStack) / float(this.count);
  };

  /*
    Attach a function onto onFullLoad and it will run whenever the imageloader is all loaded and
    has started (must use startLoad since there is the possibility that while pushing images, the load counter
    reaches 0 and sends signal to onFullLoad before all is pushed)
    
    CAN ATTACH MULTIPLE FUNCTIONS,
    IF YOU WANT TO ERASE ALL FUNCTIONS ATTACHED SAY VARIABLE_NAME.loadedFunc = EMPTY_FUNCTION
  */


  ImageLoader.prototype.onFullLoad = function(updateFunc) {
    var oldLoaded;
    oldLoaded = this.loadedFunc;
    if (this.loadedFunc) {
      return this.loadedFunc = function() {
        if (oldLoaded) oldLoaded();
        return updateFunc();
      };
    } else {
      return this.loadedFunc = updateFunc;
    }
  };

  ImageLoader.prototype.clear = function() {
    return this.imageHolder = [];
  };

  return ImageLoader;

})();

Pane = (function() {

  Pane.name = 'Pane';

  function Pane(img) {
    this.image = img;
  }

  Pane.prototype.createTexture = function(gl) {
    this.texture = gl.createTexture();
    this.texture.image = this.image;
    doLoadImageTexture(gl, this.texture.image, this.texture);
    return handleLoadedTexture(gl, this.texture);
  };

  Pane.prototype.weightedPoint = function(point) {
    var degrees, fitPatt, hours, matches, minutes, seconds;
    fitPatt = /([0-9][0-9])([0-9][0-9])([0-9])([+-])([0-9][0-9])([0-9][0-9])([0-9])E.fits/gi;
    matches = fitPatt.exec(point);
    hours = parseInt(matches[1], 10);
    minutes = parseInt(matches[2], 10);
    seconds = parseInt(matches[3], 10);
    seconds /= 10.0;
    minutes += seconds;
    minutes /= 60.0;
    hours += minutes;
    hours *= 15;
    this.RA = hours;
    /*
          Now calculate DEC
    */

    degrees = parseInt(matches[5], 10);
    minutes = parseInt(matches[6], 10);
    seconds = parseInt(matches[7], 10);
    this.DEC = degrees;
    minutes = minutes + seconds / 10.0;
    this.DEC = this.DEC + minutes / 60.0;
    if (matches[4] === '-') return this.DEC = 0 - this.DEC;
  };

  return Pane;

})();

Overlay = (function() {

  Overlay.name = 'Overlay';

  function Overlay(gl) {
    this.insertImages = __bind(this.insertImages, this);

    this.constructPane = __bind(this.constructPane, this);
    this.gl = gl;
    this.index = 0;
    this.indices = [];
    this.textureCoords = [];
    this.vertices = [];
    this.opacity = 1.0;
    this.preLoader = new ImageLoader();
    this.panes = [];
  }

  Overlay.prototype.constructPane = function(image) {
    var newPane;
    newPane = new Pane(image);
    newPane.weightedPoint(image.src);
    this.pushBounds(newPane);
    if (image.height !== 1024 || image.width !== 1024) return;
    newPane.createTexture(this.gl);
    this.pushTexture(newPane);
    return this.panes.push(newPane);
  };

  Overlay.prototype.getImageArray = function(boundingBox) {
    this.insertImages(['00000+00000E.fits.jpg']);
    if (this.span.RAMax < boundingBox.RAMax) this.span.RAMax = boundingBox.RAMax;
    if (this.span.RAMin > boundingBox.RAMin) this.span.RAMin = boundingBox.RAMin;
    if (this.span.DecMax < boundingBox.DecMax) {
      this.span.DecMax = boundingBox.DecMax;
    }
    if (this.span.DecMin > boundingBox.DecMin) {
      return this.span.DecMin = boundingBox.DecMin;
    }
  };

  Overlay.prototype.insertImages = function(arr) {
    var url, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      url = arr[_i];
      _results.push(this.preLoader.pushImage(url, this.constructPane));
    }
    return _results;
  };

  Overlay.prototype.pushBounds = function(pane) {
    if ((pane.RA + .256) > this.span.RAMax) {
      this.span.RAMax = pane.RA + .256;
    } else if ((pane.RA - .256) < this.span.RAMin) {
      this.span.RAMin = pane.RA - .256;
    }
    if ((pane.Dec + .256) > this.span.DecMax) {
      return this.span.DecMax = pane.Dec + .256;
    } else if ((pane.Dec - .256) < this.span.DecMin) {
      return this.span.DecMin = pane.Dec - .256;
    }
  };

  Overlay.prototype.pushTexture = function(pane) {
    var bottom, left, right, top;
    right = 1.0 - Math.round(pane.RA / .512) * 2;
    left = -1.0 - Math.round(pane.RA / .512) * 2;
    top = 1.0 + Math.round(pane.DEC / .512) * 2;
    bottom = -1.0 + Math.round(pane.DEC / .512) * 2;
    this.vertices.push(left);
    this.vertices.push(bottom);
    this.vertices.push(0);
    this.vertices.push(right);
    this.vertices.push(bottom);
    this.vertices.push(0);
    this.vertices.push(right);
    this.vertices.push(top);
    this.vertices.push(0);
    this.vertices.push(left);
    this.vertices.push(top);
    this.vertices.push(0);
    this.indices.push(this.index);
    this.indices.push(this.index + 1);
    this.indices.push(this.index + 2);
    this.indices.push(this.index);
    this.indices.push(this.index + 2);
    this.indices.push(this.index + 3);
    this.index += 4;
    this.textureCoords.push(0.0);
    this.textureCoords.push(0.0);
    this.textureCoords.push(1.0);
    this.textureCoords.push(0.0);
    this.textureCoords.push(1.0);
    this.textureCoords.push(1.0);
    this.textureCoords.push(0.0);
    return this.textureCoords.push(1.0);
  };

  Overlay.prototype.clear = function() {
    this.opacity = 1.0;
    return this.panes = [];
  };

  Overlay.prototype.display = function(view) {
    var i, indexObject, pane, texCoordObject, vertexObject, _i, _len, _ref, _results;
    texCoordObject = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, texCoordObject);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.textureCoords), this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
    vertexObject = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexObject);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertices), this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
    indexObject = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, indexObject);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexObject);
    this.gl.vertexAttribPointer(this.gl.vertexPosition, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, texCoordObject);
    this.gl.vertexAttribPointer(this.gl.texturePosition, 2, this.gl.FLOAT, false, 0, 0);
    this.gl.mvMatrix.setUniform(this.gl, this.gl.u_modelViewMatrix, false);
    this.gl.perspectiveMatrix.setUniform(this.gl, this.gl.u_projectionMatrix, false);
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, indexObject);
    i = 0;
    _ref = this.panes;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pane = _ref[_i];
      if (pane.texture && this.withinView(view, pane)) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, pane.texture);
        this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, i);
      } else if (this.withinView(view, pane)) {
        pane.createTexture(this.gl);
        this.gl.bindTexture(this.gl.TEXTURE_2D, pane.texture);
        this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, i);
      } else if (!(pane.texture === null)) {
        console.log("Removed pane from field");
        this.gl.deleteTexture(pane.texture);
        pane.texture = null;
      }
      _results.push(i += 12);
    }
    return _results;
  };

  Overlay.prototype.withinView = function(view, pane) {
    return (view.RAMax > (pane.RA - .512) && view.RAMin < (pane.RA + .512)) && (view.DecMax > (pane.DEC - .512) && view.DecMin < (pane.DEC + .512));
  };

  Overlay.prototype.withinSpan = function(bound) {
    return (bound.RAMax < this.span.RAMax) && (bound.RAMin > this.span.RAMin) && (bound.DecMax < this.span.DecMax) && (bound.DecMin > this.span.DecMin);
  };

  return Overlay;

})();

/*
*/


SDSSOverlay = (function(_super) {

  __extends(SDSSOverlay, _super);

  SDSSOverlay.name = 'SDSSOverlay';

  function SDSSOverlay() {
    this.insertImages = __bind(this.insertImages, this);

    this.constructPane = __bind(this.constructPane, this);
    return SDSSOverlay.__super__.constructor.apply(this, arguments);
  }

  SDSSOverlay.prototype.constructPane = function(image) {
    var newPane;
    newPane = new Pane(image);
    newPane.RA = arguments[1];
    newPane.DEC = arguments[2];
    newPane.createTexture(this.gl);
    this.pushBounds(newPane);
    this.pushTexture(newPane);
    return this.panes.push(newPane);
  };

  SDSSOverlay.prototype.insertImages = function(arr) {
    var dec, newurl, point, ra, url, _i, _len, _results,
      _this = this;
    _results = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      url = arr[_i];
      point = Util.prototype.calculateRADEC(url);
      ra = point[0];
      dec = point[1];
      newurl = "http://astro.cs.pitt.edu/astroshelfTIM/db/remote/SDSS.php?scale=" + 1.8 + "&ra=" + ra + "&dec=" + dec + "&width=1024&height=1024";
      _results.push(this.preLoader.pushImage(newurl, (function(ra, dec) {
        var decf, fun, raf;
        raf = ra;
        decf = dec;
        fun = _this.constructPane;
        return function(image) {
          return fun(image, raf, decf);
        };
      })(ra, dec)));
    }
    return _results;
  };

  return SDSSOverlay;

})(Overlay);
